"use strict";
var core_1 = require('@angular/core');
var masking_service_1 = require('../../utility/services/masking.service');
var validation_service_1 = require('../../utility/services/validation.service');
/**
 * @Component: Input
 * @Section: Forms
 * @Description: This is the input component and is used to generate text inputs
*/
var InputComponent = (function () {
    // Constructor
    function InputComponent(maskingService, validationService) {
        var _this = this;
        this.maskingService = maskingService;
        this.validationService = validationService;
        // The size of the input
        this.inputSize = 'large';
        // The type of the input
        this.inputType = 'text';
        // If the input is required
        this.isRequired = false;
        // Phone area type toggle
        this.phoneArea = false;
        // Phone country type toggle
        this.phoneCountry = false;
        // Classes to be applied to the wrapper
        this.wrapperClasses = {
            'has-value': false,
            'is-focused': false,
            'form-group': true
        };
        // Classes for the sizes of input, also applied to the wrapper
        this.sizes = {
            large: 'col-md-8 col-lg-8 col-sm-12',
            medium: 'col-md-6 col-sm-9 col-xs-12',
            small: 'col-md-4 col-sm-6 col-xs-12',
            xsmall: 'col-md-2 col-sm-3 col-xs-6',
            none: ''
        };
        // Classes to be applied to the input group
        this.groupClasses = {
            'tooltip-input-group': false,
            'input-group': false,
            'combo-group': false,
            'focus-group': false
        };
        // Classes to be applied to the input
        this.inputClasses = {
            'form-control': true,
            'formatted': false,
            'validation-input-danger': false
        };
        // Moves focus to the input
        this.focusInput = function () {
            this.input.nativeElement.focus();
        };
        // On focus
        this.onFocus = function () {
            // Set the focused class
            this.wrapperClasses['is-focused'] = true;
        };
        this.getMask = function (value) {
            return _this.inputMaskArray;
        };
        // On Blur
        this.onBlur = function () {
            // Set the focused class
            this.wrapperClasses['is-focused'] = false;
            this.validate();
        };
        // Returns the value of the input on key up
        this.onInput = function () {
            // Set the has-value class
            this.value.length
                ? this.wrapperClasses['has-value'] = true
                : this.wrapperClasses['has-value'] = false;
            // Report the change
            this.valueChange.emit({
                value: this.value
            });
        };
        // Clears an error state on the input. Takes a type of error
        this.toggleError = function (errorType, isErrored) {
            // Clear the error state
            this.error = isErrored;
            // Clear the error class
            this.inputClasses['validation-input-danger'] = isErrored;
            // Set the error on the validation service
            if (isErrored) {
                // Add the error type
                this.errorType = errorType;
                // Add the error to the validation service
                this.validationService.addError(this);
            }
            else {
                // Remove the error type
                this.errorType = null;
                // Remove the error from the validation service
                this.validationService.removeError(this);
            }
            // Emit the change to the error
            this.errorChange.emit();
        };
        // validate input
        this.validate = function () {
            // Get the current value
            var value = this.input.nativeElement.value;
            // If we got a value
            if (value) {
                // If the input is required
                if (this.required) {
                    // Clear the required error state
                    this.toggleError('required', false);
                }
                // If there is a mininum input length
                if (this.minlength) {
                    // Get the length of the value of the input
                    var length_1 = value.length;
                    // If the length is longer than the minimum length set on the input
                    if (length_1 >= parseInt(this.minlength, 10)) {
                        // Clear the minlength error state
                        this.toggleError('minlength', false);
                    }
                    else {
                        // Otherwise set the error message
                        this.errorMessage = this.minLengthError || this.errors['minLength'];
                        // And set the minlength error state
                        this.toggleError('minlength', true);
                    }
                }
            }
            else {
                // Otherwise if there was no value and the input is required
                if (this.required && (!this.value || this.value === 'undefined')) {
                    // Set the error message
                    this.errorMessage = this.requiredError || this.errors['required'];
                    // And set the required error state
                    this.toggleError('required', true);
                }
            }
        };
        /**
          * @Event: valueChange
          * @Description: This event that is fired when the value of the input changes. Can be bound to with (valueChange)='myFunction($event)'
          * @Return: Object
        */
        this.valueChange = new core_1.EventEmitter();
        /**
          * @Property: currency
          * @Description: This defines the type of the currency being input
          * @Type: String
        */
        this.currency = 'dollar';
        /**
          * @Property: errorMessage
          * @Description: error message to be displayed when no value is selected
          * @Type: string
        */
        this.errorMessage = 'Error';
        /**
          * @Property: error
          * @Description: This defines the error state on the input
          * @Type: String
        */
        this.error = false;
        this.errorChange = new core_1.EventEmitter();
    }
    ;
    // OnInit
    InputComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.labelId = this.idStr + 'label';
        // Subscribe to the validation to validate the input on request of the service
        this.validationService.validateNow.subscribe(function () {
            _this.validate();
        });
        // Set the error messages
        this.errors = {
            required: 'Input is required',
            minLength: 'Input length must exceed ' + this.minlength + ' characters',
            maxLength: 'Input length must exceed ' + this.minlength + ' characters'
        };
    };
    Object.defineProperty(InputComponent.prototype, "type", {
        /**
          * @Property: type
          * @Description: This defines the type of the input, which changes which kind of input is displayed. Mask must be set separately.
          * @Type: String ('text', 'password', 'email', 'url', 'phoneNumber', 'phoneCountry', 'phoneArea', 'readOnly', 'ssn'), defaults to text.
        */
        set: function (type) {
            // Define the valid types
            var validTypes = [
                'text', 'password', 'email', 'url', 'phoneNumber', 'phoneCountry', 'phoneArea', 'readOnly', 'ssn'
            ];
            // If there is a type and it is valid
            if (type && validTypes.indexOf(type) !== -1) {
                switch (type) {
                    case 'phoneCountry':
                        this.phoneCountry = true;
                        break;
                    case 'phoneArea':
                        this.phoneArea = true;
                        break;
                }
                // Set the input type
                this.inputType = type;
            }
            else if (core_1.isDevMode) {
                console.error('CITI-INPUT - TYPE: Caught \'' + type + '\'. Valid types are: ' + validTypes);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputComponent.prototype, "size", {
        /**
          * @Property: size
          * @Description: This defines the size of the input, which changes the bootstrap classes.
          * @Type: String ('large', 'medium', 'small', 'xsmall', 'none'), defaults to large.
        */
        set: function (size) {
            // Define the valid sizes
            var validSizes = ['large', 'medium', 'small', 'xsmall', 'none'];
            // If there is a size and it is valid
            if (size && validSizes.indexOf(size) !== -1) {
                // Set the input size
                this.inputSize = size;
            }
            else if (core_1.isDevMode) {
                console.error('CITI-INPUT - SIZE: Caught \'' + size + '\'. Valid sizes are: ' + validSizes);
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(InputComponent.prototype, "mask", {
        /**
          * @Property: mask
          * @Description: This defines the mask of the input, which changes the input text masking on character input.
          * @Type: String ('none', 'phone', 'date', 'zipcode', 'dollar', 'email'), defaults to none.
        */
        set: function (mask) {
            // Define valid mask types
            var validMasks = ['none', 'phone', 'zipcode', 'dollar', 'email', 'ssn'];
            // If there is a mask and it is a valid mask
            if (mask && validMasks.indexOf(mask) !== -1) {
                // If the mask type is not none (handled internally)
                if (mask !== 'none') {
                    // Set the mask array from the masking service
                    this.inputMaskArray = this.maskingService.getMask(mask);
                }
            }
            else if (mask && validMasks.indexOf(mask) === -1 && core_1.isDevMode) {
                console.error('CITI-CTI - MASK: Caught \'' + mask + '\'. Valid values are: ' + validMasks);
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        core_1.ViewChild('input'), 
        __metadata('design:type', core_1.ElementRef)
    ], InputComponent.prototype, "input", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "idStr", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "name", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "label", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "value", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], InputComponent.prototype, "valueChange", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "placeholder", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], InputComponent.prototype, "type", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], InputComponent.prototype, "size", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], InputComponent.prototype, "mask", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "tooltipTitle", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "tooltipBody", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "tooltipPosition", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "currency", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], InputComponent.prototype, "maxlength", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], InputComponent.prototype, "minlength", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], InputComponent.prototype, "required", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "errorMessage", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], InputComponent.prototype, "error", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], InputComponent.prototype, "errorChange", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "requiredError", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "minLengthError", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], InputComponent.prototype, "describedby", void 0);
    InputComponent = __decorate([
        core_1.Component({
            selector: 'citi-input',
            template: require('./input.component.html'),
            styles: [require('./input.component.scss')],
            providers: [masking_service_1.MaskingService]
        }), 
        __metadata('design:paramtypes', [masking_service_1.MaskingService, validation_service_1.ValidationService])
    ], InputComponent);
    return InputComponent;
}());
exports.InputComponent = InputComponent;
//# sourceMappingURL=input.component.js.map