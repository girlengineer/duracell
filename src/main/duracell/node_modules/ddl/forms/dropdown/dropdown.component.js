"use strict";
var core_1 = require('@angular/core');
var dropdown_service_1 = require("./dropdown-service/dropdown.service");
var validation_service_1 = require("../../utility/services/validation.service");
/**
 * @Component: Dropdown
 * @Section: Forms
 * @Description: This is the dropdown component and is used to create reusable dropdown field
 * from Bootstrap.
*/
var DropdownComponent = (function () {
    function DropdownComponent(dropdownService, validationService) {
        this.dropdownService = dropdownService;
        this.validationService = validationService;
        // Strings for the different sizes of dropdown
        this.sizeClasses = {
            large: 'col-md-8 col-sm-12',
            medium: 'col-md-6 col-sm-9 col-xs-12',
            small: 'col-md-4 col-sm-6 col-xs-12',
            xsmall: 'col-md-2 col-sm-3 col-xs-6'
        };
        // Classes to be applied to the dropdown
        this.classes = {
            focus: '',
            size: ''
        };
        // Classes to be applied to the input
        this.inputClasses = {
            'validation-input-danger': false
        };
        // Array to hold the options as they are added
        this.options = [];
        // Whether or not the dropdown is hidden
        this.hidden = false;
        // Whether the dropdown should have auto focus or not
        this.hasAutoFocus = false;
        // Whether or not the dropdown is required
        this.isRequired = false;
        // Whether or not the dropdown has a tooltip
        this.dropdownHasTooltip = false;
        // Default messages for errors
        this.errors = {
            required: 'Input is required'
        };
        // On Focus
        this.onFocus = function () {
            // Add the is-focused class
            this.classes.focus = "is-focused";
        };
        // On Blur
        this.onBlur = function () {
            // If the dropdown is required and there is no selected value
            if (this.isRequired && (!this.selectedValue || this.selectedValue == "undefined")) {
                // Let the dropdown know there is an error
                this.error = true;
            }
            // Remove the is-focused class
            this.classes.focus = '';
            if (this.change) {
                // Add the is-focused class
                this.classes.focus = "is-focused";
            }
            this.validate();
        };
        // On Change
        this.onDropdownChange = function () {
            // If the dropdown is required and there is no selected value
            if (this.isRequired && (!this.selectedValue || this.selectedValue == "undefined")) {
                // Toggle the error state
                this.toggleError("required", true);
            }
            else if (this.error && this.selectedValue && this.selectedValue != "undefined") {
                // Clear the error
                this.toggleError("required", false);
            }
            // If there is a change function
            if (this.change) {
                // Add the is-focused class
                this.classes.focus = "is-focused";
                // Call it and pass the currently selected value
                this.change.emit(this.selectedValue);
            }
        };
        // Clears an error state on the input. Takes a type of error
        this.toggleError = function (errorType, isErrored) {
            // Clear the error state
            this.error = isErrored;
            // Clear the error class
            this.inputClasses['validation-input-danger'] = isErrored;
            // Set the error on the validation service
            if (isErrored) {
                // Add the error type
                this.errorType = errorType;
                // Add the error to the validation service
                this.validationService.addError(this);
            }
            else {
                // Remove the error type
                this.errorType = null;
                // Remove the error from the validation service
                this.validationService.removeError(this);
            }
            // Emit the change to the error
            this.errorChange.emit();
        };
        // validate input
        this.validate = function () {
            // Get the current value
            var value = this.selectedValue;
            // If we got a value
            if (value) {
                // If the input is required
                if (this.required) {
                    // Clear the required error state
                    this.toggleError("required", false);
                }
            }
            else {
                // Otherwise if there was no value and the input is required
                if (this.required && (!this.value || this.value === 'undefined')) {
                    // Set the error message
                    this.errorMessage = this.requiredError || this.errors['required'];
                    // And set the required error state
                    this.toggleError("required", true);
                }
            }
        };
        /**
        * @Property: change
        * @Description: takes a function to be called when the value of the dropdown is changed.
        * @Type: Function
        */
        this.change = new core_1.EventEmitter();
        /**
        * @Property: size
        * @Description: size for the dropdown (large, medium, small, xsmall)
        * @Type: string
        */
        this.size = "large";
        /**
          * @Property: errorMessage
          * @Description: error message to be displayed when no value is selected
          * @Type: string
        */
        this.errorMessage = 'Error';
        /**
          * @Property: error
          * @Description: This defines the error state on the input
          * @Type: String
        */
        this.error = false;
        this.errorChange = new core_1.EventEmitter();
        /**
        * @Property: tooltipPosition
        * @Description: Position for the dropdown tooltip (top, bottom, left, right, auto)
        * @Type: string
        */
        this.tooltipPosition = "auto";
    }
    // OnInit
    DropdownComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.labelId = this.idStr + 'label';
        // Set the appropriate size class
        this.classes.size = this.sizeClasses[this.size];
        // Listen for options to be added
        this.dropdownService.optionAdded.subscribe(function (option) {
            // Add the option to the options array
            _this.options.push(option);
            // If the option should be selected
            if (option.isSelected) {
                // Set the selected value to this options value
                // Note that if multiple options are set as selected, 
                // the last set as selected will be selected
                _this.selectedValue = option.value;
                // Call on change to update parent component
                _this.onDropdownChange();
            }
        });
        // Subscribe to the validation to validate the input on request of the service
        this.validationService.validateNow.subscribe(function () {
            _this.validate();
        });
    };
    Object.defineProperty(DropdownComponent.prototype, "isHidden", {
        /**
        * @Property: hidden
        * @Description: whether the dropdown is hidden or not
        * @Type: boolean
        */
        set: function (hidden) {
            if (hidden == true || hidden == "true") {
                this.isHidden = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropdownComponent.prototype, "autofocus", {
        /**
        * @Property: autofocus
        * @Description: whether the dropdown should be focused automatically on page load
        * @Type: boolean
        */
        set: function (autofocus) {
            if (autofocus == true || autofocus == "true") {
                this.hasAutoFocus = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropdownComponent.prototype, "hasTooltip", {
        /**
        * @Property: hasTooltip
        * @Description: whether the dropdown has a tooltip or not
        * @Type: boolean
        */
        set: function (tooltip) {
            if (tooltip == true || tooltip == "true") {
                this.dropdownHasTooltip = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], DropdownComponent.prototype, "change", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "idStr", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "name", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "size", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "label", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], DropdownComponent.prototype, "isHidden", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], DropdownComponent.prototype, "autofocus", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], DropdownComponent.prototype, "required", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "errorMessage", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], DropdownComponent.prototype, "error", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], DropdownComponent.prototype, "errorChange", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "requiredError", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], DropdownComponent.prototype, "hasTooltip", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "tooltipTitle", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "tooltipBody", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], DropdownComponent.prototype, "tooltipPosition", void 0);
    DropdownComponent = __decorate([
        core_1.Component({
            selector: 'citi-dropdown',
            template: require('./dropdown.component.html'),
            styles: [require('./dropdown.component.scss')],
            providers: [dropdown_service_1.DropdownService]
        }), 
        __metadata('design:paramtypes', [dropdown_service_1.DropdownService, validation_service_1.ValidationService])
    ], DropdownComponent);
    return DropdownComponent;
}());
exports.DropdownComponent = DropdownComponent;
//# sourceMappingURL=dropdown.component.js.map