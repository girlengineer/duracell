"use strict";
var core_1 = require('@angular/core');
/**
  * @Component: Slider
  * @Section: Forms
  * @Description: This is the slider component and is used slide a specific numeric value selection visually.
  * The slider component also supports a range selection.
*/
var SliderComponent = (function () {
    function SliderComponent(element) {
        this.element = element;
        this.handleClicked = false;
        this.side = 'left';
        this.mouseup = new core_1.EventEmitter();
        this.mousedown = new core_1.EventEmitter();
        this.mousemove = new core_1.EventEmitter();
        this.mouseuprange = new core_1.EventEmitter();
        this.mousedownrange = new core_1.EventEmitter();
        this.mousemoverange = new core_1.EventEmitter();
        this.pos = 0;
        this.posStr = this.pos + 'px';
        this.rangeBool = false;
        this.posRange = 0;
        /**
          * @Property: minValue
          * @Description: This defines the minimum value selectable by the slider
          * @Type: Number (Integer)
        */
        this.minValue = 0;
        /**
          * @Property: maxValue
          * @Description: This defines the maximum value selectable by the slider
          * @Type: Number (Integer)
        */
        this.maxValue = 7;
        /**
          * @Property: curValue
          * @Description: This defines the current value of the slider
          * @Type: Number (Integer)
        */
        this.curValue = 2;
        /**
          * @Property: width
          * @Description: This defines the width of the slider component
          * @Type: Number (pixels)
        */
        this.width = this.element.nativeElement.getBoundingClientRect().width;
        /**
          * @Property: displayValues
          * @Description: This defines the visibility of the slider min and max labels
          * @Type: Boolean
        */
        this.displayValues = true;
        /**
          * @Property: legendText
          * @Description: This defines the text of the slider legend above the inputs
          * @Type: String
        */
        this.legendText = 'Range';
        /**
          * @Property: legendSRText
          * @Description: This defines the text of the slider legend for screen readers only
          * @Type: String
        */
        this.legendSRText = 'Set Minimum and Maximum Values to set a range';
        /**
          * @Property: minimumText
          * @Description: This defines the text of the minimum input label
          * @Type: String
        */
        this.minimumText = 'Range minimum';
        /**
          * @Property: maximumText
          * @Description: This defines the text of the maximum input label
          * @Type: String
        */
        this.maximumText = 'Range maximum';
        /**
          * @Property: rangeStart
          * @Description: This defines the start value of the left handle if the slider is set to be a range.
          * @Type: Number (Integer)
        */
        this.rangeStart = 0;
        /**
          * @Property: rangeEnd
          * @Description: This defines the end value of the left handle if the slider is set to be a range.
          * @Type: Number (Integer)
        */
        this.rangeEnd = 2;
        /**
          * @Event: curValueChange
          * @Description: This event is fired when the value of the slider changes (only when not a range slider). The event is returned.
          * @Return: Object
        */
        this.curValueChange = new core_1.EventEmitter();
        /**
          * @Event: rangeStartChange
          * @Description: This event is fired when the start value of the range slider changes (only when a range slider). The event is returned.
          * @Return: Object
        */
        this.rangeStartChange = new core_1.EventEmitter();
        /**
          * @Event: rangeEndChange
          * @Description: This event is fired when the end value of the range slider changes (only when a range slider). The event is returned.
          * @Return: Object
        */
        this.rangeEndChange = new core_1.EventEmitter();
    }
    Object.defineProperty(SliderComponent.prototype, "direction", {
        /**
          * @Property: direction
          * @Description: This defines the direction of the slider handle when the user drags a selection
          * @Type: String ('left' or 'right')
        */
        set: function (side) {
            this.side = side;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "range", {
        /**
          * @Property: range
          * @Description: This defines if the slider is a range. A range slider has two handles.
          * @Type: Boolean
        */
        set: function (value) {
            if (typeof value == "boolean" || value == "true" || value == "false") {
                if (typeof value == 'string') {
                    this.rangeBool = (value == "true");
                }
                else if (typeof value == 'boolean') {
                    this.rangeBool = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    SliderComponent.prototype.onMouseup = function (event) {
        this.mouseuprange.next(event);
        if (this.rangeBool == true) {
            this.rangeStart = this.getNewSliderValue(this.posRange);
            this.setSliderRangePosition(true, (this.width * (this.rangeStart / this.maxValue)));
            this.rangeEnd = this.getNewSliderValue(this.pos);
            this.setSliderRangePosition(false, (this.width * (this.rangeEnd / this.maxValue)));
        }
        else {
            this.curValue = this.getNewSliderValue(this.pos);
            this.setSliderPosition((this.width * (this.curValue / this.maxValue)));
        }
        this.mouseup.next(event);
    };
    /**
      * @Function: setStart
      * @Description: This function sets the start value of a range slider.
      * @Param: (Event) - value - Value to set start.
      * @Return: Void
    */
    SliderComponent.prototype.setStart = function (event) {
        var newValue = event.value;
        console.log(newValue);
        if (!isNaN(newValue)) {
            newValue = parseInt(event.value);
        }
        else {
            newValue = null;
        }
        if (newValue) {
            if (this.rangeBool == true) {
                if (newValue > this.rangeEnd) {
                    newValue = this.rangeEnd;
                }
                else if (newValue < 0) {
                    newValue = 0;
                }
                this.rangeStart = newValue;
                this.setSliderRangePosition(true, (this.width * (this.rangeStart / this.maxValue)));
            }
            else {
                if (newValue < 0) {
                    newValue = 0;
                }
                else if (newValue > this.maxValue) {
                    newValue = this.maxValue;
                }
                this.curValue = newValue;
                this.setSliderPosition((this.width * (this.curValue / this.maxValue)));
            }
        }
        ;
    };
    /**
      * @Function: setEnd
      * @Description: This function sets the end value of a range slider.
      * @Param: (Event) - value - Value to set end.
      * @Return: Void
    */
    SliderComponent.prototype.setEnd = function (event) {
        var newValue = event.value;
        if (!isNaN(newValue)) {
            newValue = parseInt(event.value);
        }
        else {
            newValue = null;
        }
        if (newValue) {
            if (newValue < this.rangeStart) {
                newValue = this.rangeStart;
            }
            else if (newValue > this.maxValue) {
                newValue = this.maxValue;
            }
            this.rangeEnd = newValue;
            this.setSliderRangePosition(false, (this.width * (this.rangeEnd / this.maxValue)));
        }
    };
    SliderComponent.prototype.onMouseDown = function (event) {
        this.mousedown.next(event);
        event.stopPropagation();
    };
    SliderComponent.prototype.onMouseDownRange = function (event) {
        this.mousedownrange.next(event);
        event.stopPropagation();
    };
    SliderComponent.prototype.onMouseMove = function (event) {
        this.mousemoverange.next(event);
        this.mousemove.next(event);
    };
    SliderComponent.prototype.onResize = function (event) {
        var oldWidth = this.width;
        var ratio = this.pos / oldWidth;
        this.width = this.element.nativeElement.getBoundingClientRect().width;
        if (this.width < 930) {
            this.paddClass = 'noPadd';
        }
        else {
            this.paddClass = '';
        }
        if (this.rangeBool == true) {
            var ratioRange = this.posRange / oldWidth;
            this.setSliderRangePosition(true, (ratioRange * this.width));
            this.setSliderRangePosition(false, (ratio * this.width));
        }
        else {
            this.setSliderPosition((ratio * this.width));
        }
    };
    SliderComponent.prototype.onHandleKey = function (event) {
        var code = event.keyCode;
        if (code != 9) {
            event.preventDefault();
        }
        if (code == 40 || code == 37) {
            if (this.rangeBool == true) {
                if (this.rangeEnd > 0) {
                    this.rangeEnd -= 1;
                    this.setSliderRangePosition(false, this.width * (this.rangeEnd / this.maxValue));
                }
            }
            else {
                if (this.curValue > 0) {
                    this.curValue -= 1;
                    this.setSliderPosition((this.width * (this.curValue / this.maxValue)));
                }
            }
        }
        else if (code == 38 || code == 39) {
            if (this.rangeBool == true) {
                if (this.rangeEnd < this.maxValue) {
                    this.rangeEnd += 1;
                    this.setSliderRangePosition(false, this.width * (this.rangeEnd / this.maxValue));
                }
            }
            else {
                if (this.curValue < this.maxValue) {
                    this.curValue += 1;
                    this.setSliderPosition((this.width * (this.curValue / this.maxValue)));
                }
            }
        }
    };
    SliderComponent.prototype.onRangeHandleKey = function (event) {
        var code = event.keyCode;
        if (code != 9) {
            event.preventDefault();
        }
        if (code == 40 || code == 37) {
            if (this.rangeStart > 0) {
                this.rangeStart -= 1;
                this.setSliderRangePosition(true, this.width * (this.rangeStart / this.maxValue));
            }
        }
        else if (code == 38 || code == 39) {
            if (this.rangeStart < this.rangeEnd) {
                this.rangeStart += 1;
                this.setSliderRangePosition(true, this.width * (this.rangeStart / this.maxValue));
            }
        }
    };
    SliderComponent.prototype.slideClick = function (event) {
        if (!this.handleClicked) {
            var offsetX = event.offsetX;
            if (this.rangeBool == true) {
            }
            else {
                this.curValue = this.getNewSliderValue(offsetX);
                this.setSliderPosition((this.width * (this.curValue / this.maxValue)));
            }
        }
        else {
            this.handleClicked = false;
        }
    };
    SliderComponent.prototype.getNewSliderValue = function (position) {
        var newValue = Math.round((position / this.width) * this.maxValue);
        return newValue;
    };
    /**
      * @Function: setSliderPosition
      * @Description: This function sets the position of the slider (when not a range).
      * @Param: (Number) - value - Value to set the position of the slider (pixels).
      * @Return: Void
    */
    SliderComponent.prototype.setSliderPosition = function (value) {
        this.pos = value;
        var newSliderValue = 0;
        if (this.side == 'right') {
            this.posLeftStr = 'inherit';
            this.lineLeft = 'inherit';
            this.posRightStr = (this.width - (this.pos + 20)) + 'px';
            this.lineRight = '0';
            this.posStr = (this.width - this.pos) + 'px';
            newSliderValue = Math.round((1 - (this.pos / this.width)) * this.maxValue);
        }
        else {
            this.lineLeft = '0';
            this.posRightStr = 'inherit';
            this.lineRight = 'inherit';
            this.posStr = this.pos + 'px';
            this.posLeftStr = this.posStr;
            newSliderValue = Math.round((this.pos / this.width) * this.maxValue);
        }
        if (newSliderValue != this.curValue) {
            this.curValue = newSliderValue;
            this.curValueChange.emit({
                value: this.curValue
            });
            this.startInput.value = this.curValue;
        }
        this.lineWidth = this.posStr;
    };
    /**
      * @Function: setSliderRangePosition
      * @Description: This function sets the position of the slider when it's a range.
      * @Param: (Boolean) - left - Boolean to set the position of the left or right side of the range.
      * True sets the position of the left side of the range, false sets the position of the right side of the range.
      * @Param: (Number) - value - Value to set the position of the slider (pixels).
      * @Return: Void
    */
    SliderComponent.prototype.setSliderRangePosition = function (left, value) {
        if (left == true) {
            this.posRange = value;
        }
        else {
            this.pos = value;
        }
        this.posRightStr = 'inherit';
        if (left == true) {
            this.posLeftRangeStr = this.posRange + 'px';
            this.lineLeft = this.posRange + 'px';
            this.lineWidth = this.pos - this.posRange + 'px';
            var newSliderValue = 0;
            newSliderValue = Math.round((this.posRange / this.width) * this.maxValue);
            if (newSliderValue != this.rangeStart) {
                this.rangeStart = newSliderValue;
                this.rangeStartChange.emit({
                    value: this.rangeStart
                });
                this.startInput.value = this.rangeStart;
            }
        }
        else {
            if (this.pos <= this.posRange) {
                this.pos = (this.posRange + 40);
            }
            this.posLeftStr = this.pos + 'px';
            this.lineWidth = (this.pos - this.posRange) + 'px';
            var newSliderValue = 0;
            newSliderValue = Math.round((this.pos / this.width) * this.maxValue);
            if (newSliderValue != this.rangeEnd) {
                this.rangeEnd = newSliderValue;
                this.rangeEndChange.emit({
                    value: this.rangeEnd
                });
                this.endInput.value = this.rangeEnd;
            }
        }
    };
    SliderComponent.prototype.ngAfterViewInit = function () {
        if (this.options) {
            this.width = this.options.width;
            this.minValue = this.options.minValue;
            this.maxValue = this.options.maxValue;
            this.curValue = this.options.curValue;
            this.displayValues = this.options.displayValues;
            this.rangeBool = this.options.range;
            this.rangeStart = this.options.rangeStart;
            this.rangeEnd = this.options.rangeEnd;
        }
        this.width = this.slideLine.nativeElement.getBoundingClientRect().width;
        if (this.width < 930) {
            this.paddClass = 'noPadd';
        }
        else {
            this.paddClass = '';
        }
        if (this.rangeBool == true) {
            this.setSliderRangePosition(true, this.width * (this.rangeStart / this.maxValue));
            this.setSliderRangePosition(false, this.width * (this.rangeEnd / this.maxValue));
        }
        else {
            if (this.side == 'right') {
                this.setSliderPosition(this.width * (1 - (this.curValue / this.maxValue)));
            }
            else {
                this.setSliderPosition(this.width * (this.curValue / this.maxValue));
            }
        }
    };
    SliderComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.rangeBool == false) {
            this.minimumText = 'Slider value';
        }
        this.mousedrag = this.mousedown.map(function (event) {
            event.stopPropagation();
            event.preventDefault();
            _this.handleClicked = true;
            return {
                x: event.clientX,
                left: event.target.offsetLeft,
                right: event.target.offsetRight,
                width: event.target.clientWidth
            };
        })
            .flatMap(function (imageOffset) { return _this.mousemove.map(function (pos) {
            var halfWidth = imageOffset.width / 2;
            var pLeft = (pos.clientX - imageOffset.x) + imageOffset.left + halfWidth;
            if (_this.rangeBool == true) {
                if (pLeft < (_this.posRange + 20)) {
                    pLeft = _this.posRange + 20;
                }
            }
            else {
                if (pLeft < 5)
                    pLeft = 5;
            }
            if (pLeft > (_this.width))
                pLeft = _this.width;
            return {
                left: pLeft
            };
        })
            .takeUntil(_this.mouseup); });
        this.mousedrag.subscribe({
            next: function (pos) {
                if (_this.rangeBool == true) {
                    _this.setSliderRangePosition(false, pos.left);
                }
                else {
                    _this.setSliderPosition(pos.left);
                }
            }
        });
        this.mousedragrange = this.mousedownrange.map(function (event) {
            event.stopPropagation();
            event.preventDefault();
            _this.handleClicked = true;
            return {
                x: event.clientX,
                left: event.target.offsetLeft,
                right: event.target.offsetRight,
                width: event.target.clientWidth
            };
        })
            .flatMap(function (imageOffset) { return _this.mousemoverange.map(function (pos) {
            var halfWidth = imageOffset.width / 2;
            var pLeft = (pos.clientX - imageOffset.x) + imageOffset.left + halfWidth;
            if (pLeft < 5)
                pLeft = 5;
            if (pLeft > (_this.pos - 20))
                pLeft = _this.pos - 20;
            return {
                left: pLeft
            };
        })
            .takeUntil(_this.mouseup); });
        this.mousedragrange.subscribe({
            next: function (pos) {
                _this.setSliderRangePosition(true, pos.left);
            }
        });
    };
    __decorate([
        core_1.ViewChild('slideLine'), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "slideLine", void 0);
    __decorate([
        core_1.ViewChild('startInput'), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "startInput", void 0);
    __decorate([
        core_1.ViewChild('endInput'), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "endInput", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "minValue", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "maxValue", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "curValue", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "width", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], SliderComponent.prototype, "displayValues", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], SliderComponent.prototype, "legendText", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], SliderComponent.prototype, "legendSRText", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], SliderComponent.prototype, "minimumText", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], SliderComponent.prototype, "maximumText", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], SliderComponent.prototype, "direction", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], SliderComponent.prototype, "range", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "rangeStart", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], SliderComponent.prototype, "rangeEnd", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "options", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "curValueChange", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "rangeStartChange", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], SliderComponent.prototype, "rangeEndChange", void 0);
    __decorate([
        core_1.HostListener('window:mouseup', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [MouseEvent]), 
        __metadata('design:returntype', void 0)
    ], SliderComponent.prototype, "onMouseup", null);
    __decorate([
        core_1.HostListener('mousemove', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], SliderComponent.prototype, "onMouseMove", null);
    __decorate([
        core_1.HostListener('window:resize', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], SliderComponent.prototype, "onResize", null);
    SliderComponent = __decorate([
        core_1.Component({
            selector: 'citi-slider',
            template: require('./slider.component.html'),
            styles: [require('./slider.component.css')]
        }), 
        __metadata('design:paramtypes', [core_1.ElementRef])
    ], SliderComponent);
    return SliderComponent;
}());
exports.SliderComponent = SliderComponent;
//# sourceMappingURL=slider.component.js.map