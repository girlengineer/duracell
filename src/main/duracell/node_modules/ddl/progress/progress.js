"use strict";
var step_1 = require('./step');
var utility_classes_1 = require('../utility/utility.classes');
var core_1 = require("@angular/core");
var Progress = (function () {
    function Progress(steps, isFirstStepActive) {
        if (steps === void 0) { steps = []; }
        if (isFirstStepActive === void 0) { isFirstStepActive = false; }
        this.onActiveStepChanged = new core_1.EventEmitter();
        if (utility_classes_1.JavascriptMethods.isArray(steps)) {
            // If we have an array items
            if (steps.length > 0) {
                for (var index = 0; index < steps.length; index++) {
                    var value = steps[index];
                    if (utility_classes_1.JavascriptMethods.isString(value)) {
                        var newStep = new step_1.Step(value);
                        this.addStep(newStep);
                    }
                }
            }
            else {
                this._steps = [];
            }
        }
        else {
            this._steps = [];
        }
        // If the step list is empty
        if (this._steps.length === 0) {
            // Return null as there is no step to retrieve
            this.currentStepIndex = null;
        }
        else {
            // Sets the first step as default
            this.currentStepIndex = 0;
        }
        if (isFirstStepActive === true && this.numberOfSteps > 0) {
            this.setStepActive(0);
        }
    }
    Progress.prototype.setFinishedStepsToPosition = function (atPosition) {
        for (var index = 0; index < atPosition; index++) {
            this._steps[index].setFinished();
        }
    };
    Progress.prototype.setNormalStepsFromPosition = function (atPosition) {
        for (var index = atPosition + 1; index < this._steps.length; index++) {
            this._steps[index].setNormal();
        }
    };
    Progress.prototype.setActiveStep = function () {
        // Sets the current step to be active
        this._steps[this.currentStepIndex].setActive();
        // Since there only one active step in a progress,
        // sets finished state to all the steps prior to the current step
        this.setFinishedStepsToPosition(this.currentStepIndex);
        this.setNormalStepsFromPosition(this.currentStepIndex);
    };
    Progress.prototype.isItemDeletable = function () {
        return this._steps.length > 2;
    };
    Progress.prototype.addStep = function (newStep, atPosition, isCurrentStep) {
        var isAtPositionValid = utility_classes_1.JavascriptMethods.isInteger(atPosition);
        // If the new step is not supposed to change the active step, verifies again with the position specified.
        // We have to update the active step if the new position equals to the active step position
        if (isCurrentStep !== true) {
            isCurrentStep = isAtPositionValid && atPosition === this.currentStepIndex;
        }
        // Updates the state of the active step if needed
        if (this.currentStepIndex !== null && isCurrentStep === true) {
            if (atPosition > this.currentStepIndex) {
                this._steps[this.currentStepIndex].setFinished();
            }
            if (atPosition <= this.currentStepIndex) {
                this._steps[this.currentStepIndex].setNormal();
            }
        }
        // Checks if we have the current step parameter
        if (isAtPositionValid) {
            // Adds the new step to the specified position
            this._steps.splice(atPosition, 0, newStep);
        }
        else {
            // Adds to the end of the array
            this._steps.push(newStep);
            atPosition = this.numberOfSteps - 1;
        }
        // Checks if we have the optional current step specified
        if (typeof isCurrentStep !== 'undefined' && isCurrentStep === true) {
            if (isAtPositionValid) {
                // Uses the current position as the current step
                this.currentStepIndex = atPosition;
            }
            else {
                // If the new step has to be active,
                this.currentStepIndex = this.steps.length - 1;
            }
            // Performs all necessary code to change the state
            this.setActiveStep();
        }
        else {
            // Else, if we don't have to update the active step
            if (atPosition < this.currentStepIndex) {
                // The new step needs to be marked as finished
                this._steps[atPosition].setFinished();
                // Increases active step index by 1 as we inserted a new element in front of it
                this.currentStepIndex = this.currentStepIndex + 1;
            }
        }
    };
    Progress.prototype.removeAStep = function (stepIndex) {
        if (stepIndex < 0) {
            stepIndex = 0;
        }
        // The progress indicator has to have at least 2 steps. Therefore, we restricted the remove operation
        // once there are only 2 steps in the list.
        if (this.isItemDeletable()) {
            // Checks if we have the step index specified
            if (typeof stepIndex === 'undefined' || stepIndex === null) {
                if (this._steps.length > 0) {
                    // Uses the last index if nothing specified
                    stepIndex = this._steps.length - 1;
                }
                else {
                    // If the array of step is empty, just set null to ignore next processing
                    stepIndex = null;
                }
            }
            // If the deleted step is active, turns on the flag for activating another step as active
            var changeCurrentStep = this._steps[stepIndex].isActive();
            // If we can determine the step to be deleted
            if (stepIndex !== null) {
                if (utility_classes_1.JavascriptMethods.isInteger(stepIndex)) {
                    if (this._steps.length > stepIndex) {
                        // Removes the step
                        this._steps.splice(stepIndex, 1);
                        // Updates the current step
                        if (changeCurrentStep === true) {
                            this.currentStepIndex = stepIndex - 1;
                            this.setActiveStep();
                        }
                        else {
                            // If the deleted step index is in front of the active step, we have to update the active step index
                            if (stepIndex < this.currentStepIndex) {
                                this.currentStepIndex = this.currentStepIndex - 1;
                                this.setActiveStep();
                            }
                        }
                    }
                }
            }
        }
        else {
            console.warn('Cannot delete any more item from the progress indicator');
        }
    };
    Object.defineProperty(Progress.prototype, "hasSteps", {
        get: function () {
            return this._steps.length > 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "currentStep", {
        get: function () {
            if (this.currentStepIndex === null) {
                return null;
            }
            return this._steps[this.currentStepIndex];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "numberOfSteps", {
        get: function () {
            return this._steps.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "currentStepIndex", {
        get: function () {
            if (this._steps.length > 0 && typeof this._currentStep !== 'undefined' && this._currentStep !== null) {
                return this._currentStep;
            }
            return null;
        },
        set: function (stepIndex) {
            if (utility_classes_1.JavascriptMethods.isInteger(stepIndex)) {
                var steps = [];
                if (this._currentStep !== null) {
                    steps.push(this._steps[this._currentStep]);
                }
                else {
                    steps.push(null);
                }
                if (stepIndex < 0) {
                    this._currentStep = 0;
                }
                else {
                    if (this._steps.length > 0) {
                        if (stepIndex >= this._steps.length) {
                            this._currentStep = this._steps.length - 1;
                        }
                        else {
                            this._currentStep = stepIndex;
                        }
                    }
                }
                steps.push(this._steps[this._currentStep]);
                // Emits event
                this.onActiveStepChanged.emit(steps);
            }
            else {
                console.warn('Invalid step index provided');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "steps", {
        get: function () {
            return this._steps.slice();
        },
        set: function (stepList) {
            this._steps = stepList;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "hasActiveStep", {
        get: function () {
            return this._steps.length > 0 && this.currentStepIndex !== null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "isAtLastStep", {
        get: function () {
            return this.currentStepIndex === this.numberOfSteps - 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Progress.prototype, "isAtFirstStep", {
        get: function () {
            return this.currentStepIndex === 0;
        },
        enumerable: true,
        configurable: true
    });
    Progress.prototype.setStepActive = function (stepIndex) {
        if (utility_classes_1.JavascriptMethods.isInteger(stepIndex)) {
            if (stepIndex > -1) {
                if (stepIndex < this._steps.length) {
                    this.currentStepIndex = stepIndex;
                    this.setActiveStep();
                }
                else {
                    console.warn('Provided index is out of range.');
                }
            }
            else {
                console.warn('Provided index is out of range.');
            }
        }
    };
    Progress.prototype.clearAllSteps = function () {
        this._steps = [];
        this._currentStep = null;
    };
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], Progress.prototype, "onActiveStepChanged", void 0);
    return Progress;
}());
exports.Progress = Progress;
//# sourceMappingURL=progress.js.map