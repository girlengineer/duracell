"use strict";
var core_1 = require('@angular/core');
var TooltipComponent = (function () {
    function TooltipComponent() {
        this.popupOpacity = 0;
        this.popupPosition = 'auto';
        this.popupClicked = false;
        this._hasHelpIcon = 'true';
        this.title = '';
        this.body = '';
        this.additionalClassName = '';
        this.isFocusTriggered = false;
        this.zIndex = "-1";
    }
    Object.defineProperty(TooltipComponent.prototype, "position", {
        set: function (position) {
            this.popupPosition = position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipComponent.prototype, "additionalClass", {
        set: function (className) {
            this.additionalClassName = className;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipComponent.prototype, "tooltipTargetElement", {
        set: function (tooltipTargetElement) {
            this.tooltipTarget = tooltipTargetElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipComponent.prototype, "tooltipTitle", {
        set: function (tooltipTitle) {
            this.title = tooltipTitle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipComponent.prototype, "tooltipBody", {
        set: function (body) {
            this.body = body;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipComponent.prototype, "hasHelpIcon", {
        set: function (hasHelpIcon) {
            this._hasHelpIcon = hasHelpIcon;
        },
        enumerable: true,
        configurable: true
    });
    TooltipComponent.prototype.togglePopup = function () {
        /*
        if (this.popupClicked === true) {
          this.popupClicked = false;
          this.popupOpacity = 0;
          this.zIndex = '-1';
          this.isFocusTriggered = false;
        } else {
          this.popupClicked = true;
          this.popupOpacity = 1;
          this.zIndex = '1060';
        }
        */
    };
    TooltipComponent.prototype.blurListener = function () {
        var _this = this;
        this.isFocusTriggered = false;
        setTimeout(function () {
            if (!_this.isFocusTriggered) {
                _this.popupOpacity = 0;
                _this.popupClicked = false;
                _this.zIndex = '-1';
            }
        }, 100);
    };
    TooltipComponent.prototype.focusInListener = function () {
        this.popupOpacity = 1;
        this.zIndex = '1060';
    };
    TooltipComponent.prototype.focusOutListener = function () {
        this.popupOpacity = 0;
        this.zIndex = '-1';
    };
    TooltipComponent.prototype.getPopoverPosition = function () {
        var element = this._hasHelpIcon === 'true' && this.tooltipHelpIcon ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget;
        if (element) {
            if (this.popupPosition === 'auto') {
                this.popupPosition = this.b('right auto', element);
            }
            return this.popupPosition + ' ' + this.additionalClassName;
        }
        return '';
    };
    TooltipComponent.prototype.getPopoverXYPosition = function () {
        var element = this._hasHelpIcon === 'true' && this.tooltipHelpIcon ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget;
        if (element) {
            var bodyRect = document.body.getBoundingClientRect(), elemRect = element.getBoundingClientRect(), verticalOffset = void 0, horizontalOffset = void 0;
            switch (this.popupPosition) {
                case 'top':
                    verticalOffset = elemRect.top - bodyRect.top - this.popover.nativeElement.offsetHeight;
                    horizontalOffset = elemRect.left - bodyRect.left + element.offsetWidth / 2 - this.popover.nativeElement.offsetWidth / 2;
                    break;
                case 'bottom':
                    verticalOffset = elemRect.top - bodyRect.top + element.offsetHeight;
                    horizontalOffset = elemRect.left - bodyRect.left + element.offsetWidth / 2 - this.popover.nativeElement.offsetWidth / 2;
                    break;
                case 'right':
                    verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight / 2) + element.offsetHeight / 2;
                    horizontalOffset = elemRect.left - bodyRect.left + element.offsetWidth;
                    break;
                case 'left':
                    verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight / 2) + element.offsetHeight / 2;
                    horizontalOffset = elemRect.left - bodyRect.left - this.popover.nativeElement.offsetWidth;
                    break;
            }
            return { 'display': 'block', 'top': verticalOffset + 'px', 'left': horizontalOffset + 'px' };
        }
        else {
            return '';
        }
    };
    TooltipComponent.prototype.b = function (a, b) {
        var windowDimention = {
            width: window.innerWidth,
            height: window.innerHeight
        }, elementRect = b.getBoundingClientRect(), positionArr = {
            right: function () {
                return windowDimention.width - (elementRect.width + elementRect.left);
            },
            left: function () {
                return elementRect.left;
            },
            bottom: function () {
                return windowDimention.height - (elementRect.height + elementRect.top);
            }
        }, e = a.replace(/ *auto */i, ''), position = {
            pos: e,
            size: 0
        }, maxWidth = 340;
        if (positionArr[e]() <= maxWidth) {
            for (var side in positionArr) {
                var i = positionArr[side]();
                if (i >= maxWidth) {
                    e = side;
                    break;
                }
                i > position.size && (position.size = i, position.pos = side);
            }
        }
        e = (positionArr[e]() <= maxWidth) ? 'bottom' : e;
        return e;
    };
    TooltipComponent.prototype.ngOnInit = function () {
    };
    TooltipComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var element = this._hasHelpIcon === 'true' ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget;
        element.addEventListener('click', function (e) {
            /*
            if (this.popupClicked === true) {
              this.popupClicked = false;
              this.popupOpacity = 0;
              this.zIndex = '-1';
            } else {
              this.popupClicked = true;
              this.popupOpacity = 1;
              this.zIndex = '1060';
            }
            */
        });
        element.addEventListener('mouseover', function (e) {
            _this.popupOpacity = 1;
            _this.zIndex = '1060';
        });
        element.addEventListener('mouseleave', function (e) {
            if (_this.popupClicked === false) {
                _this.popupOpacity = 0;
                _this.zIndex = '-1';
            }
        });
        element.addEventListener('blur', function (e) {
            _this.isFocusTriggered = false;
            setTimeout(function () {
                if (!_this.isFocusTriggered) {
                    _this.popupOpacity = 0;
                    _this.popupClicked = false;
                    _this.zIndex = '-1';
                }
            }, 100);
        });
        element.addEventListener('focus', function (e) {
            _this.focusInListener();
        });
        element.addEventListener('focusout', function (e) {
            _this.focusOutListener();
        });
    };
    __decorate([
        core_1.ViewChild('popover'), 
        __metadata('design:type', core_1.ElementRef)
    ], TooltipComponent.prototype, "popover", void 0);
    __decorate([
        core_1.ViewChild('tooltipHelpIcon'), 
        __metadata('design:type', core_1.ElementRef)
    ], TooltipComponent.prototype, "tooltipHelpIcon", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], TooltipComponent.prototype, "position", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], TooltipComponent.prototype, "additionalClass", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object), 
        __metadata('design:paramtypes', [Object])
    ], TooltipComponent.prototype, "tooltipTargetElement", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], TooltipComponent.prototype, "tooltipTitle", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], TooltipComponent.prototype, "tooltipBody", null);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String), 
        __metadata('design:paramtypes', [String])
    ], TooltipComponent.prototype, "hasHelpIcon", null);
    TooltipComponent = __decorate([
        core_1.Component({
            selector: 'citi-tooltip',
            template: require('./tooltip.component.html')
        }), 
        __metadata('design:paramtypes', [])
    ], TooltipComponent);
    return TooltipComponent;
}());
exports.TooltipComponent = TooltipComponent;
//# sourceMappingURL=tooltip.component.js.map