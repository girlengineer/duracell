/**
 * @module CoreServicesModule
 **/
/** SessionService **/
"use strict";
var core_1 = require('@angular/core');
var http_1 = require('@angular/http');
var router_1 = require('@angular/router');
var Rx_1 = require('rxjs/Rx');
var ng2_cookies_1 = require('ng2-cookies/ng2-cookies');
var services_1 = require('../services');
/**
 * The SessionService provides session management related behavior.
 *
 * Declare sessionService object {SessionServiceConfig} in Application Config
 * <pre>
 * sessionService: {
 *   sessionTimeout: number; #Specify the number of seconds for sessionTimeout
 *   keepAliveInterval: number; #Specify the interval used to send keep alive request if there is user activity in the browser.
 *   sessionKeepAliveUrl: string; #Specifiy the keep alive URL where to send the keep alive request.
 *   sessionCookies: string[]; #Specify the names of the cookies related to the session of the user.
 * }
 *</pre>
 * @class SessionService
 * @constructor
 **/
var SessionService = (function () {
    function SessionService(_appConfigService, _http, _router) {
        this._appConfigService = _appConfigService;
        this._http = _http;
        this._router = _router;
    }
    /**
       * The start method is used to start the session timer. It recevies a SessionTimeoutHandler. When the session timeout occurs, it will execute the handleSessionTimeout method of SessionTimeoutHandler object.
       *
       * @method start
       * @public
       * @param customTimeoutHandler {SessionTimeoutHandler} When the session timeout occurs, the handleSessionTimouet method of this object is called.
       * @returns {void}
    */
    SessionService.prototype.start = function (customTimeoutHandler) {
        if (this._sessionTimeoutSubscription) {
            this._sessionTimeoutSubscription.unsubscribe();
        }
        this._customTimeoutHandler = customTimeoutHandler.handleSessionTimeout;
        this._sessionTimeoutObservable = Rx_1.Observable.timer(this._appConfigService.getSessionServiceConfig().sessionTimeout * 1000);
        var keepAliveInterval = this._appConfigService.getSessionServiceConfig().keepAliveInterval * 1000;
        this._keepAliveIntervalObservable = Rx_1.Observable.timer(keepAliveInterval, keepAliveInterval);
        var self = this;
        this.activityFlag = false;
        document.addEventListener("click", function () {
            self.activityFlag = true;
        });
        this._keepAliveIntervalHandler = function () {
            if (self.activityFlag) {
                self.activityFlag = false;
                self.renew();
            }
        };
        this._keepAliveIntervalObserver = {
            next: function (x) {
                self._keepAliveIntervalHandler();
            },
            error: function (err) {
                console.log('KeepAliveIntervalObserver Err: %s', err);
            },
            complete: function () {
            }
        };
        this._sessionTimeoutObserver = {
            next: function (x) {
            },
            error: function (err) {
                console.log('SessionTimeoutObserver Err: %s', err);
            },
            complete: function () {
                self._customTimeoutHandler();
            }
        };
        this._sessionTimeoutSubscription = this._sessionTimeoutObservable.subscribe(this._sessionTimeoutObserver);
        this._keepAliveIntervalSubscription = this._keepAliveIntervalObservable.subscribe(this._keepAliveIntervalObserver);
    };
    /**
       * The renew method sends a keep alive request to the url specified in the sessionKeepAliveUrl property of the SessionServiceConfig object in the Application Config.
       * After the keep alive request is sent, it will also restart the session timeout timer.
       * @method start
       * @public
       * @param customTimeoutHandler {SessionTimeoutHandler} When the session timeout occurs, the handleSessionTimouet method of this object is called.
       * @returns {void}
    */
    SessionService.prototype.renew = function () {
        this._sessionTimeoutSubscription.unsubscribe();
        var self = this;
        this._http.get(this._appConfigService.getSessionServiceConfig().sessionKeepAliveUrl).catch(function (error) {
            self._customTimeoutHandler();
            return Rx_1.Observable.throw("KeepAlive error");
        }).subscribe(function (response) { });
        this._sessionTimeoutSubscription = this._sessionTimeoutObservable.subscribe(this._sessionTimeoutObserver);
    };
    /**
       * The hasSessionCookies method returns true if all the cookies declared in the sessionCookies array property in the Application Config are present in the browser. If at least one of the cookies is not present it returns false.
       * @method hasSessionCookies
       * @public
       * @returns {boolean}
    */
    SessionService.prototype.hasSessionCookies = function () {
        var sessionCookies = this._appConfigService.getSessionServiceConfig().sessionCookies;
        for (var index in sessionCookies) {
            if (!ng2_cookies_1.Cookie.get(sessionCookies[index])) {
                return false;
            }
        }
        return true;
    };
    SessionService = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [services_1.AppConfigService, http_1.Http, router_1.Router])
    ], SessionService);
    return SessionService;
}());
exports.SessionService = SessionService;
//# sourceMappingURL=session.service.js.map