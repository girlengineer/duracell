import { Component, OnInit, Input, ElementRef, ViewChild } from '@angular/core';
import { PasswordStrengthControlSettings, PopoverSettings } from './password-strength-control.component.Settings';
import { InputSizeCss, InputSize, InputOffsetCss, JavascriptMethods } from '../../utility/utility.classes';


@Component({
  selector: 'citi-password-strength-control',
  template: require('./password-strength-control.component.html')
})
export class PasswordStrengthControlComponent implements OnInit {
  private settings: PasswordStrengthControlSettings = new PasswordStrengthControlSettings();
  private generatedCSS: string = 'form-group ';
  private active: boolean = true;
  private customStatusText: string = '';
  private generatedValidationHTML: string = '';
  private isValid: boolean = false;
  private error: boolean = false;
  private psiValue: string = '';
  private validators: Array<any> = [];
  private hideTooltip: boolean = true;
  private isFocusTriggered: boolean = false;
  private formGroupEl: any = undefined;
  private popoverSettings: PopoverSettings = new PopoverSettings();
  private zIndex: string = '-1';

  @ViewChild('psiInput') psiInput: ElementRef;
  @ViewChild('psiHelp') psiHelp: ElementRef;
  @ViewChild('popover') popover: ElementRef;

  @Input()
  set type( settings: PasswordStrengthControlSettings ){
    this.settings = settings;
  }
  @Input()
  set inputSize ( inputSize: any ){
    this.settings.inputSize = inputSize;
  }
  @Input()
  set id ( id: string ){
    this.settings.id = id;
  }
  @Input()
  set labelText ( labelText: string ){
    this.settings.labelText = labelText;
  }
  @Input()
  set errorText ( errorText: string ){
    this.settings.errorText = errorText;
  }
  @Input()
  set validStatusText ( validStatusText: string ){
    this.settings.validStatusText = validStatusText;
  }
  @Input()
  set invalidStatusText ( invalidStatusText: string ){
    this.settings.invalidStatusText = invalidStatusText;
  }
  @Input()
  set initialStatusText ( initialStatusText: string ){
    this.settings.initialStatusText = initialStatusText;
  }
  @Input()
  set rulesHeaderText ( rulesHeaderText: string ){
    this.settings.rulesHeaderText = rulesHeaderText;
  }
  @Input()
  set userIDFieldID ( userIDFieldID: string ){
    this.settings.userIDFieldID = userIDFieldID;
  }
  @Input()
  set userIDCheckMessage ( userIDCheckMessage: string ){
    this.settings.userIDCheckMessage = userIDCheckMessage;
  }
  @Input()
  set spaceCheckMessage ( spaceCheckMessage: string ){
    this.settings.spaceCheckMessage = spaceCheckMessage;
  }
  @Input()
  set letterCheckMessage ( letterCheckMessage: string ){
    this.settings.letterCheckMessage = letterCheckMessage;
  }
  @Input()
  set numberCheckMessage ( numberCheckMessage: string ){
    this.settings.numberCheckMessage = numberCheckMessage;
  }
  @Input()
  set lengthCheckMessage ( lengthCheckMessage: string ){
    this.settings.lengthCheckMessage = lengthCheckMessage;
  }
  @Input()
  set minLength ( minLength: string ){
    this.settings.minLength = minLength;
  }
  @Input()
  set maxLength ( maxLength: string ){
    this.settings.maxLength = maxLength;
  }
  @Input()
  set placeholder ( placeholder: string ){
    this.settings.placeholder = placeholder;
  }
  @Input()
  set isHidden ( isHidden: boolean ){
    this.settings.isHidden = isHidden;
  }
  @Input()
  set offsetLG ( offsetLG: string ){
    this.settings.offsetLG = offsetLG;
  }
  @Input()
  set offsetMD ( offsetMD: string ){
    this.settings.offsetMD = offsetMD;
  }
  @Input()
  set offsetSM ( offsetSM: string ){
    this.settings.offsetSM = offsetSM;
  }
  @Input()
  set offsetXS ( offsetXS: string ){
    this.settings.offsetXS = offsetXS;
  }
  @Input()
  set hasHelpIcon ( hasHelpIcon: string ){
    this.settings.hasHelpIcon = hasHelpIcon;
  }
  @Input()
  set popoverPosition ( popoverPosition: any ){
    this.popoverSettings.popoverPosition = popoverPosition;
  }
  constructor() {

  }
  ngOnInit() {
    let _setting: PasswordStrengthControlSettings = this.settings;
    switch (_setting.inputSize) {
      case InputSize.FullBody:
        this.generatedCSS += InputSizeCss.FullBody;
        break;
      case InputSize.Large:
        this.generatedCSS += InputSizeCss.Large;
        break;
      case InputSize.Medium:
        this.generatedCSS += InputSizeCss.Medium;
        break;
      case InputSize.Small:
        this.generatedCSS += InputSizeCss.Small;
        break;
      case InputSize.XSmall:
        this.generatedCSS += InputSizeCss.Small;
        break;
      default:
        console.log(_setting.inputSize);
    }
    if (_setting.offsetXS !== '') {
      this.generatedCSS += InputOffsetCss.XSmall + _setting.offsetXS + ' ';
    }
    if (_setting.offsetSM !== '') {
      this.generatedCSS += InputOffsetCss.Small + _setting.offsetSM + ' ';
    }
    if (_setting.offsetMD !== '') {
      this.generatedCSS += InputOffsetCss.Medium + _setting.offsetMD + ' ';
    }
    if (_setting.offsetLG !== '') {
      this.generatedCSS += InputOffsetCss.Large + _setting.offsetLG + ' ';
    }
    if ( _setting.userIDCheckMessage !== '' && _setting.userIDFieldID !== '') {
      this.validators.push({
        message: _setting.userIDCheckMessage,
        isValid: (value: any) => {
          return value !== '';
        }
      });
    }
    if ( _setting.spaceCheckMessage !== '') {
      this.validators.push({
        message: _setting.spaceCheckMessage,
        isValid: (value: any) => {
          return value.indexOf(' ') === -1;
        }
      });
    }
    if ( _setting.letterCheckMessage !== '') {
      this.validators.push({
        message: _setting.letterCheckMessage,
        isValid: (value: any) => {
          return value.match(/[a-z]/i) !== null;
        }
      });
    }
    if ( _setting.numberCheckMessage !== '') {
      this.validators.push({
        message: _setting.numberCheckMessage,
        isValid: (value: any) => {
          return value.match(/\d/) !== null;
        }
      });
    }
    if ( _setting.lengthCheckMessage !== '') {
      this.validators.push({
        message: _setting.lengthCheckMessage,
        isValid: (value: any) => {
          return value.length >= this.settings.minLength && value.length <= this.settings.maxLength;
        }
      });
    }
  }
  private psiBlur () {
    if (this.formGroupEl === undefined)
    {
      this.formGroupEl = JavascriptMethods.closestByClass(this.psiInput.nativeElement, 'form-group');
    }
    JavascriptMethods.removeClass(this.formGroupEl, 'is-focused');
    this.blurListener();
  }
  private blurListener (){
    this.isFocusTriggered = false;
    setTimeout(() => {
      if (!this.isFocusTriggered) {
        this.error = !this.isValid;
        this.hideTooltip = true;
        this.popoverSettings.popupOpacity = 0;
        this.zIndex = '-1';
      }
    }, 150);
  }
  private psiFocus () {
    if (this.formGroupEl === undefined) {
      this.formGroupEl = JavascriptMethods.closestByClass(this.psiInput.nativeElement, 'form-group');
    }
    JavascriptMethods.addClass(this.formGroupEl, 'is-focused');
    this.focusListener();
  }
  private focusListener () {
    this.isFocusTriggered = true;
    this.hideTooltip = false;
    this.createPasswordValidatorHTML(this.psiInput.nativeElement.className.indexOf('ng-pristine') !== -1, false);
    this.popoverSettings.popupOpacity = 1;
    this.zIndex = '1060';
  }
  private psiKeyUp (e: any) {
    if (e.keyCode !== 9 && e.keyCode !== 13 && e.keyCode !== 16 ) {
        this.error = false;
        this.createPasswordValidatorHTML(false, false);
      }
  }
  private psiChange() {
    if (this.formGroupEl === undefined) {
      this.formGroupEl = JavascriptMethods.closestByClass(this.psiInput.nativeElement, 'form-group');
    }
    if (this.psiInput.nativeElement.value !== '') {
      JavascriptMethods.addClass(this.formGroupEl, 'has-value');
    } else {
      JavascriptMethods.removeClass(this.formGroupEl, 'has-value');
    }
  }
  private createPasswordValidatorHTML(isInitial: Boolean = false,
                                      isExternalError: Boolean = false) {
    let validators: Array<any> = this.validators,
        passwordValue: string = this.psiValue,
        validationHTML: Array<string> = [],
        isValid = true,
        generatedValidationHTML = '';
      if (passwordValue === undefined) {
        isInitial = true;
      }
      for (let i = 0, len = validators.length; i < len; i++) {
        if (isInitial) {
          validationHTML.push(`<li>${validators[i].message}</li>`);
        } else if ( validators[i].isValid(passwordValue)) {
          validationHTML.push(`<li class="check-mark">
                                  ${validators[i].message}
                                </li>`);
        } else {
          isValid = false;
          validationHTML.push(`<li class="x-mark">
                                  ${validators[i].message}
                                </li>`);
        }
      }
      if (isInitial) {
        generatedValidationHTML =  `<span class="password-status">${this.settings.initialStatusText}</span>
                                    <h3 class="popover-title">${this.settings.rulesHeaderText}</h3>
                                    <ul>${validationHTML.join('')}</ul>`;
      } else if (isValid) {
        let txt = isExternalError ? this.customStatusText : this.settings.validStatusText;
        generatedValidationHTML =  `<span class="password-status is-passing ">${txt}</span>
                                    <h3 class="popover-title">${this.settings.rulesHeaderText}</h3>
                                    <ul>${validationHTML.join('')}</ul>`;
      } else {
        let txt = isExternalError ? this.customStatusText : this.settings.invalidStatusText;
        generatedValidationHTML =  `<span class="password-status is-passing ">${txt}</span>
                                    <h3 class="popover-title">${this.settings.rulesHeaderText}</h3>
                                    <ul>${validationHTML.join('')}</ul>`;
      }
      this.generatedValidationHTML = generatedValidationHTML;
      this.isValid = isValid;

  }
  private getPopoverPosition(): any {
    let element  = this.settings.hasHelpIcon ? this.psiHelp : this.psiInput;
    if (element) {
    if (this.popoverSettings.popoverPosition === 'auto') {
        this.popoverSettings.popoverPosition = this.b('right auto', element.nativeElement);
      }
    return this.popoverSettings.popoverPosition;
    }
    return '';
  }
  private getPopoverXYPosition(): any {
    let element  = this.settings.hasHelpIcon ? this.psiHelp : this.psiInput;
    if (element) {
      let bodyRect = document.body.getBoundingClientRect(),
          elemRect = element.nativeElement.getBoundingClientRect(),
          verticalOffset: any,
          horizontalOffset: any;
      switch (this.popoverSettings.popoverPosition) {
        case 'top' :
          verticalOffset   = elemRect.top - bodyRect.top  - this.popover.nativeElement.offsetHeight;
          horizontalOffset = elemRect.left - bodyRect.left + element.nativeElement.offsetWidth/2 - this.popover.nativeElement.offsetWidth/2;
          break;
        case 'bottom' :
          verticalOffset   = elemRect.top - bodyRect.top + element.nativeElement.offsetHeight;
          horizontalOffset = elemRect.left - bodyRect.left + element.nativeElement.offsetWidth/2 - this.popover.nativeElement.offsetWidth/2;
          break;
        case 'right' :
          verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight/2) + element.nativeElement.offsetHeight/2;
          horizontalOffset   = elemRect.left - bodyRect.left + element.nativeElement.offsetWidth;
          break;
        case 'left' :
          verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight/2) + element.nativeElement.offsetHeight/2;
          horizontalOffset   = elemRect.left - bodyRect.left - this.popover.nativeElement.offsetWidth;
          break;
      }
      return {'display' : 'block', 'top': verticalOffset + 'px', 'left': horizontalOffset + 'px'};
    } else {
      return '';
    }
  }
  private b(a: any , b: any) {
        let windowDimention = {
            width: window.innerWidth,
            height: window.innerHeight
        },
        elementRect = b.getBoundingClientRect(),
        positionArr = {
            right: function() {
                return windowDimention.width - (elementRect.width + elementRect.left)
            },
            left: function() {
                return elementRect.left;
            },
            bottom: function() {
                return windowDimention.height - (elementRect.height + elementRect.top)
            }
        }
        , e = a.replace(/ *auto */i, '')
        , position = {
          pos: e,
          size: 0
        }
        , maxWidth = 340;
      if (positionArr[e]() <= maxWidth) {
        for (let side in positionArr) {
              let i = positionArr[side]();
              if (i >= maxWidth) {
                  e = side;
                  break;
                }
              i > position.size && (position.size = i,position.pos = side);
          }
      }
      e = (positionArr[e]() <= maxWidth) ? 'bottom' : e;
      return e;
  }
  public addCustomPasswordValidators(validators: Array<any>) {
    this.validators.concat(validators);
    this.createPasswordValidatorHTML(this.psiInput.nativeElement.className.indexOf('ng-pristine') !== -1, false);
  }
  public setCustomPasswordValidators(validators: Array<any>) {
    this.validators = validators;
    this.createPasswordValidatorHTML(this.psiInput.nativeElement.className.indexOf('ng-pristine') !== -1, false);
  }
  public triggerCheck() {
    this.psiFocus();
  }
  public resetIndicator() {
    this.generatedValidationHTML = '';
    this.isValid = false;
    this.error = false;
    this.psiValue = '';
    this.customStatusText = '';
    this.isFocusTriggered = false;
    this.active = false;
    setTimeout(() => this.active = true, 0);
  }
}
