import {Component, Input, Output, ElementRef, Inject, OnInit, AfterViewInit, HostListener, EventEmitter, ViewChild} from '@angular/core';
import {ISliderOptions} from './slider.component.options';

/**
  * @Component: Slider
  * @Description: This is the slider component and is used slide a specific numeric value selection visually.
  * The slider component also supports a range selection.
*/
@Component({
    selector: 'citi-slider',
    template: require('./slider.component.html'),
    styles: [ require('./slider.component.css') ]
})

export class SliderComponent implements OnInit  {

  elementRef: ElementRef;
  slideValue: number;
  handleClicked = false;
  side: 'left' | 'right' = 'left';
  paddClass:string;

  mousedrag:any;
  mousedragrange:any;

  mouseup   = new EventEmitter();
  mousedown = new EventEmitter();
  mousemove = new EventEmitter();

  mouseuprange   = new EventEmitter();
  mousedownrange = new EventEmitter();
  mousemoverange = new EventEmitter();

  pos = 0;
  posStr = this.pos + 'px';  
  posLeftStr:string;
  posRightStr:string;

  lineWidth:string;
  lineLeft:string;
  lineRight:string;

  rangeBool:boolean = false;
  posRange = 0;
  posLeftRangeStr:string;

  @ViewChild('slideLine') slideLine:any;
  @ViewChild('startInput') startInput:any;
  @ViewChild('endInput') endInput:any;

  /**
    * @Property: minValue 
    * @Description: This defines the minimum value selectable by the slider
    * @Type: Number (Integer) 
  */

  @Input() minValue:number = 0;

  /**
    * @Property: maxValue 
    * @Description: This defines the maximum value selectable by the slider
    * @Type: Number (Integer) 
  */

  @Input() maxValue:number = 7;

  /**
    * @Property: curValue 
    * @Description: This defines the current value of the slider
    * @Type: Number (Integer) 
  */
  
  @Input() curValue:number = 2;

  /**
    * @Property: width 
    * @Description: This defines the width of the slider component
    * @Type: Number (pixels) 
  */

  @Input() width:number = this.element.nativeElement.getBoundingClientRect().width;

  /**
    * @Property: displayValues 
    * @Description: This defines the visibility of the slider min and max labels
    * @Type: Boolean 
  */

  @Input() displayValues:boolean = true;

  /**
    * @Property: legendText 
    * @Description: This defines the text of the slider legend above the inputs
    * @Type: String 
  */

  @Input() legendText:string = 'Range';

  /**
    * @Property: legendSRText 
    * @Description: This defines the text of the slider legend for screen readers only
    * @Type: String 
  */

  @Input() legendSRText:string = 'Set Minimum and Maximum Values to set a range';

  /**
    * @Property: minimumText 
    * @Description: This defines the text of the minimum input label
    * @Type: String 
  */

  @Input() minimumText:string = 'Range minimum';

  /**
    * @Property: maximumText 
    * @Description: This defines the text of the maximum input label
    * @Type: String 
  */

  @Input() maximumText:string = 'Range maximum';

  /**
    * @Property: direction 
    * @Description: This defines the direction of the slider handle when the user drags a selection
    * @Type: String ('left' or 'right')
  */

  @Input() 
  set direction( side: any ){
    this.side = side;
  }
  
  /**
    * @Property: range 
    * @Description: This defines if the slider is a range. A range slider has two handles.
    * @Type: Boolean
  */

  @Input() 
  set range( value: any ){
    if (typeof value == "boolean" || value == "true" || value == "false"){
      if(typeof value == 'string') {        
        this.rangeBool = (value == "true");
      } else if(typeof value == 'boolean') {
        this.rangeBool = value;        
      }      
    }
  };

  /**
    * @Property: rangeStart 
    * @Description: This defines the start value of the left handle if the slider is set to be a range.
    * @Type: Number (Integer)
  */

  @Input() rangeStart:number = 0;

  /**
    * @Property: rangeEnd 
    * @Description: This defines the end value of the left handle if the slider is set to be a range.
    * @Type: Number (Integer)
  */

  @Input() rangeEnd:number = 2;

  /**
    * @Property: options 
    * @Description: This object defines all of the inputs to configure the slider component.
    * @Type: ISliderOptions
  */

  @Input() options: ISliderOptions;

  /**
    * @Event: curValueChange
    * @Description: This event is fired when the value of the slider changes (only when not a range slider). The event is returned.
    * @Return: Object
  */

  @Output() curValueChange = new EventEmitter();

  /**
    * @Event: rangeStartChange
    * @Description: This event is fired when the start value of the range slider changes (only when a range slider). The event is returned.
    * @Return: Object
  */

  @Output() rangeStartChange = new EventEmitter();

  /**
    * @Event: rangeEndChange
    * @Description: This event is fired when the end value of the range slider changes (only when a range slider). The event is returned.
    * @Return: Object
  */

  @Output() rangeEndChange = new EventEmitter();

  @HostListener('window:mouseup', ['$event'])
  onMouseup(event:MouseEvent) {
      this.mouseuprange.next(event);
      if(this.rangeBool == true) {
        this.rangeStart = this.getNewSliderValue(this.posRange);
        this.setSliderRangePosition(true, (this.width * (this.rangeStart/this.maxValue)));
        this.rangeEnd = this.getNewSliderValue(this.pos);
        this.setSliderRangePosition(false, (this.width * (this.rangeEnd/this.maxValue)));
      } else {
        this.curValue = this.getNewSliderValue(this.pos);
        this.setSliderPosition((this.width * (this.curValue/this.maxValue)));
      }
      this.mouseup.next(event);
  }

  /**
    * @Function: setStart
    * @Description: This function sets the start value of a range slider. 
    * @Param: (Event) - value - Value to set start.
    * @Return: Void
  */

  setStart(event:any) {
    let newValue = event.value;
    if(!isNaN(newValue)) {
       newValue = parseInt(event.value);
    } else {
      newValue = null;
    } 
    if(newValue) {
      if(this.rangeBool == true) {
        if(newValue > this.rangeEnd) {
          newValue = this.rangeEnd;
        } else if(newValue < 0) {
          newValue = 0;
        }
        this.rangeStart = newValue;
        this.setSliderRangePosition(true, (this.width * (this.rangeStart/this.maxValue)));
        
      } else {
        if(newValue < 0) {
          newValue = 0;
        } else if(newValue > this.maxValue) {
          newValue = this.maxValue;
        }
        this.curValue = newValue;
        this.setSliderPosition((this.width * (this.curValue/this.maxValue)));
      }
    };
  }

  /**
    * @Function: setEnd
    * @Description: This function sets the end value of a range slider. 
    * @Param: (Event) - value - Value to set end.
    * @Return: Void
  */

  setEnd(event:any) {
    let newValue = event.value;
    if(!isNaN(newValue)) {
       newValue = parseInt(event.value);
    } else {
      newValue = null;
    }
    if(newValue) {
      if(newValue < this.rangeStart) {
        newValue = this.rangeStart;
      } else if(newValue > this.maxValue) {
        newValue = this.maxValue;
      }
      this.rangeEnd = newValue;
      this.setSliderRangePosition(false, (this.width * (this.rangeEnd/this.maxValue)));
    }
  }

  onMouseDown(event:any) {
    this.mousedown.next(event);
    event.stopPropagation();
  }

  onMouseDownRange(event:any) {
    this.mousedownrange.next(event);
    event.stopPropagation();
  }

  @HostListener('mousemove', ['$event'])
  onMouseMove(event:any) {
    this.mousemoverange.next(event);
    this.mousemove.next(event);
  }

  @HostListener('window:resize', ['$event'])
  onResize(event:any) {
    let oldWidth = this.width;
    let ratio = this.pos / oldWidth;
    this.width = this.element.nativeElement.getBoundingClientRect().width;
    if(this.width < 930) {
      this.paddClass = 'noPadd';
    } else {
      this.paddClass = '';
    }

    if(this.rangeBool == true) {
      let ratioRange = this.posRange / oldWidth;
      this.setSliderRangePosition(true, (ratioRange * this.width));
      this.setSliderRangePosition(false, (ratio * this.width));
    } else {
      this.setSliderPosition((ratio * this.width));
    }
    
  }

  constructor(public element: ElementRef) {

  }

  onHandleKey(event:any) {
    let code = event.keyCode;
    if(code != 9) {
      event.preventDefault();
    }
    if(code == 40 || code == 37) {
      if(this.rangeBool == true) { 
        if(this.rangeEnd > 0) {
          this.rangeEnd -= 1;  
          this.setSliderRangePosition(false, this.width * (this.rangeEnd/this.maxValue));
        }        
      } else {
        if(this.curValue > 0) {
          this.curValue -= 1;  
          this.setSliderPosition((this.width * (this.curValue/this.maxValue)));
        }
      }

    } else if(code == 38 || code == 39) {
      if(this.rangeBool == true) { 
        if(this.rangeEnd < this.maxValue) {
          this.rangeEnd += 1;
          this.setSliderRangePosition(false, this.width * (this.rangeEnd/this.maxValue));
        }        
      } else {
        if(this.curValue < this.maxValue) {
          this.curValue += 1;
          this.setSliderPosition((this.width * (this.curValue/this.maxValue)));
        }        
      }
    }
  }

  onRangeHandleKey(event:any) {
    let code = event.keyCode;
    if(code != 9) {
      event.preventDefault();
    }
    if(code == 40 || code == 37) {
      if(this.rangeStart > 0) {
        this.rangeStart -= 1;
        this.setSliderRangePosition(true, this.width * (this.rangeStart/this.maxValue));
      }
    } else if(code == 38 || code == 39) {      
      if(this.rangeStart < this.rangeEnd) {
        this.rangeStart += 1; 
        this.setSliderRangePosition(true, this.width * (this.rangeStart/this.maxValue));
      }
    }
  }

  slideClick(event:any) {
    
    if(!this.handleClicked) {
      let offsetX = event.offsetX;
      if(this.rangeBool == true) {

      } else {
        this.curValue = this.getNewSliderValue(offsetX);
        this.setSliderPosition((this.width * (this.curValue/this.maxValue)));
      }
      
    } else {
      this.handleClicked = false;
    }
    
  }

  getNewSliderValue(position:number) {    
    let newValue = Math.round((position / this.width) * this.maxValue);    
    return newValue;
  }

  /**
    * @Function: setSliderPosition
    * @Description: This function sets the position of the slider (when not a range). 
    * @Param: (Number) - value - Value to set the position of the slider (pixels).
    * @Return: Void
  */

  setSliderPosition(value:number) {

    this.pos = value;    
    
    let newSliderValue = 0;
    if(this.side == 'right') {
      this.posLeftStr = 'inherit';
      this.lineLeft = 'inherit';
      this.posRightStr = (this.width - (this.pos+20)) + 'px';
      this.lineRight = '0';
      this.posStr = (this.width - this.pos) + 'px';
      newSliderValue = Math.round((1 - (this.pos / this.width)) * this.maxValue)
    } else {      
      this.lineLeft = '0';
      this.posRightStr = 'inherit';
      this.lineRight = 'inherit';
      this.posStr = this.pos + 'px';
      this.posLeftStr = this.posStr;
      newSliderValue = Math.round((this.pos / this.width) * this.maxValue)
    }
    
    if(newSliderValue != this.curValue) {
      this.curValue = newSliderValue;
      this.curValueChange.emit({
        value: this.curValue
      })
      this.startInput.setValue(this.curValue);
    }  

    this.lineWidth = this.posStr;

  }

  /**
    * @Function: setSliderRangePosition
    * @Description: This function sets the position of the slider when it's a range. 
    * @Param: (Boolean) - left - Boolean to set the position of the left or right side of the range.
    * True sets the position of the left side of the range, false sets the position of the right side of the range.
    * @Param: (Number) - value - Value to set the position of the slider (pixels).
    * @Return: Void
  */

  setSliderRangePosition(left:boolean, value:number) {

    if(left == true) {
      this.posRange = value;
    } else {
      this.pos = value;
    }    
            
    this.posRightStr = 'inherit';  

    if(left == true) {      
      
      this.posLeftRangeStr = this.posRange + 'px';
      this.lineLeft = this.posRange + 'px';
      this.lineWidth = this.pos - this.posRange + 'px';
      
      let newSliderValue = 0;
      newSliderValue = Math.round((this.posRange / this.width) * this.maxValue);

      if(newSliderValue != this.rangeStart) {
        this.rangeStart = newSliderValue;
        this.rangeStartChange.emit({
          value: this.rangeStart
        });
        this.startInput.setValue(this.rangeStart);
      }

    } else {
      
      if(this.pos <= this.posRange) {
        this.pos = (this.posRange + 40);
      }
      
      this.posLeftStr = this.pos + 'px';
      this.lineWidth = (this.pos - this.posRange) + 'px';
      
      let newSliderValue = 0;      
      newSliderValue = Math.round((this.pos / this.width) * this.maxValue);

      if(newSliderValue != this.rangeEnd) {
        this.rangeEnd = newSliderValue;
        this.rangeEndChange.emit({
          value: this.rangeEnd
        });
        this.endInput.setValue(this.rangeEnd);
      }
    }

  }

  ngAfterViewInit() {

    if(this.options) {
      this.width = this.options.width;
      this.minValue = this.options.minValue;
      this.maxValue = this.options.maxValue;
      this.curValue = this.options.curValue;
      this.displayValues = this.options.displayValues;
      this.rangeBool = this.options.range;
      this.rangeStart = this.options.rangeStart;
      this.rangeEnd = this.options.rangeEnd;
    }
    
    this.width = this.slideLine.nativeElement.getBoundingClientRect().width;

    if(this.width < 930) {
      this.paddClass = 'noPadd';
    } else {
      this.paddClass = '';
    }
    
    if(this.rangeBool == true) {      
      this.setSliderRangePosition(true, this.width * (this.rangeStart/this.maxValue));
      this.setSliderRangePosition(false, this.width * (this.rangeEnd/this.maxValue));
    } else {      
      if(this.side == 'right') {
        this.setSliderPosition(this.width * (1 - (this.curValue/this.maxValue)));
      } else {
        this.setSliderPosition(this.width * (this.curValue/this.maxValue));
      }
    }
    
  }

  ngOnInit() {

    if(this.rangeBool == false) {
      this.minimumText = 'Slider value';
    }

    this.mousedrag = this.mousedown.map((event:any) => {
      event.stopPropagation();
      event.preventDefault();
      this.handleClicked = true;

      return {
        x: event.clientX,
        left: event.target.offsetLeft,
        right: event.target.offsetRight,
        width: event.target.clientWidth
      };
        
    })
    .flatMap(imageOffset => this.mousemove.map(
      (pos:any) => {
          let halfWidth = imageOffset.width/2;
          let pLeft = (pos.clientX - imageOffset.x) + imageOffset.left + halfWidth;            
          if(this.rangeBool == true) {
            if(pLeft < (this.posRange + 20)) {
              pLeft = this.posRange + 20;
            }
          } else {
            if(pLeft < 5) pLeft = 5;
          }
          if(pLeft > (this.width)) pLeft = this.width;
          return {
            left: pLeft
          };
        }
    )
    .takeUntil(this.mouseup));

    this.mousedrag.subscribe({
      next: (pos:any) => {
        if(this.rangeBool == true) {
          
          this.setSliderRangePosition(false, pos.left); 
        } else {
          this.setSliderPosition(pos.left); 
        }               
      }
    });

    this.mousedragrange = this.mousedownrange.map((event:any) => {
      event.stopPropagation();
      event.preventDefault();
      this.handleClicked = true;

      return {
        x: event.clientX,
        left: event.target.offsetLeft,
        right: event.target.offsetRight,
        width: event.target.clientWidth
      };

        
    })
    .flatMap(imageOffset => this.mousemoverange.map(
      (pos:any) => {
          let halfWidth = imageOffset.width/2;
          let pLeft = (pos.clientX - imageOffset.x) + imageOffset.left + halfWidth;
          if(pLeft < 5) pLeft = 5;
          if(pLeft > (this.pos - 20)) pLeft = this.pos - 20;
          return {
            left: pLeft
          };
        }
    )
    .takeUntil(this.mouseup));

    this.mousedragrange.subscribe({
      next: (pos:any) => {
        this.setSliderRangePosition(true, pos.left);        
      }
    });
  }

}