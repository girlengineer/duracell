import {Step} from './step';
import {JavascriptMethods} from '../utility/utility.classes';
import {EventEmitter, Output} from "@angular/core";

export class Progress {
  private _steps: Step[];
  private _currentStep: number;

  @Output() onActiveStepChanged: EventEmitter<Step[]> = new EventEmitter() as EventEmitter<Step[]>;

  constructor(steps: any = [], isFirstStepActive: boolean = false) {
    if (JavascriptMethods.isArray(steps)) {
      // If we have an array items
      if (steps.length > 0) {
        for (var index = 0; index < steps.length; index++) {
          var value = steps[index];
          if(JavascriptMethods.isString(value)){
            var newStep = new Step(value);
            this.addStep(newStep);
          }
        }
      }
      else{
        this._steps = [];
      }
    }
    else{
      this._steps = [];
    }
    // If the step list is empty
    if (this._steps.length === 0) {
      // Return null as there is no step to retrieve
      this.currentStepIndex = null;
    }
    else {
      // Sets the first step as default
      this.currentStepIndex = 0;
    }

    if(isFirstStepActive === true && this.numberOfSteps > 0){
      this.setStepActive(0);
    }

  }

  private setFinishedStepsToPosition(atPosition: number) {
    for (var index = 0; index < atPosition; index++) {
      this._steps[index].setFinished();
    }
  }

  private setNormalStepsFromPosition(atPosition: number) {
    for (var index = atPosition + 1; index < this._steps.length; index++) {
      this._steps[index].setNormal();
    }
  }

  private setActiveStep() {
    // Sets the current step to be active
    this._steps[this.currentStepIndex].setActive();
    // Since there only one active step in a progress,
    // sets finished state to all the steps prior to the current step
    this.setFinishedStepsToPosition(this.currentStepIndex);
    this.setNormalStepsFromPosition(this.currentStepIndex);
  }

  private isItemDeletable() {
    return this._steps.length > 2;
  }

  public addStep(newStep: Step, atPosition?: number, isCurrentStep?: boolean) {
    var isAtPositionValid = JavascriptMethods.isInteger(atPosition);
    // If the new step is not supposed to change the active step, verifies again with the position specified.
    // We have to update the active step if the new position equals to the active step position
    if (isCurrentStep !== true) {
      isCurrentStep = isAtPositionValid && atPosition === this.currentStepIndex;
    }
    // Updates the state of the active step if needed
    if (this.currentStepIndex !== null && isCurrentStep === true) {
      if (atPosition > this.currentStepIndex) {
        this._steps[this.currentStepIndex].setFinished();
      }
      if (atPosition <= this.currentStepIndex) {
        this._steps[this.currentStepIndex].setNormal();
      }
    }
    // Checks if we have the current step parameter
    if (isAtPositionValid) {
      // Adds the new step to the specified position
      this._steps.splice(atPosition, 0, newStep);
    }
    else {
      // Adds to the end of the array
      this._steps.push(newStep);
      atPosition = this.numberOfSteps - 1;
    }
    // Checks if we have the optional current step specified
    if (typeof isCurrentStep !== 'undefined' && isCurrentStep === true) {
      if (isAtPositionValid) {
        // Uses the current position as the current step
        this.currentStepIndex = atPosition;
      }
      else {
        // If the new step has to be active,
        this.currentStepIndex = this.steps.length - 1;
      }
      // Performs all necessary code to change the state
      this.setActiveStep();
    }
    else {
      // Else, if we don't have to update the active step
      if (atPosition < this.currentStepIndex) {
        // The new step needs to be marked as finished
        this._steps[atPosition].setFinished();
        // Increases active step index by 1 as we inserted a new element in front of it
        this.currentStepIndex = this.currentStepIndex + 1;
      }
    }
  }

  public removeAStep(stepIndex?: number) {
    if (stepIndex < 0) {
      stepIndex = 0;
    }
    // The progress indicator has to have at least 2 steps. Therefore, we restricted the remove operation
    // once there are only 2 steps in the list.
    if (this.isItemDeletable()) {
      // Checks if we have the step index specified
      if (typeof stepIndex === 'undefined' || stepIndex === null) {
        if (this._steps.length > 0) {
          // Uses the last index if nothing specified
          stepIndex = this._steps.length - 1;
        }
        else {
          // If the array of step is empty, just set null to ignore next processing
          stepIndex = null;
        }
      }
      // If the deleted step is active, turns on the flag for activating another step as active
      var changeCurrentStep = this._steps[stepIndex].isActive();
      // If we can determine the step to be deleted
      if (stepIndex !== null) {
        if (JavascriptMethods.isInteger(stepIndex)) {
          if (this._steps.length > stepIndex) {
            // Removes the step
            this._steps.splice(stepIndex, 1);
            // Updates the current step
            if (changeCurrentStep === true) {
              this.currentStepIndex = stepIndex - 1;
              this.setActiveStep();
            }
            else{
              // If the deleted step index is in front of the active step, we have to update the active step index
              if(stepIndex < this.currentStepIndex){
                this.currentStepIndex = this.currentStepIndex - 1;
                this.setActiveStep();
              }
            }
          }
        }
      }
    }
    else{
      console.warn('Cannot delete any more item from the progress indicator');
    }
  }

  get hasSteps(): boolean {
    return this._steps.length > 1;
  }

  get currentStep(): Step {
    if (this.currentStepIndex === null) {
      return null;
    }
    return this._steps[this.currentStepIndex];
  }

  get numberOfSteps(): number {
    return this._steps.length;
  }

  get currentStepIndex(): number {
    if (this._steps.length > 0 && typeof this._currentStep !== 'undefined' && this._currentStep !== null) {
      return this._currentStep;
    }
    return null;
  }

  set currentStepIndex(stepIndex: number) {
    if (JavascriptMethods.isInteger(stepIndex)) {
      var steps = [];

      if(this._currentStep !== null){
        steps.push(this._steps[this._currentStep]);
      }
      else{
        steps.push(null);
      }

      if (stepIndex < 0) {
        this._currentStep = 0;
      }
      else{
        if (this._steps.length > 0) {
          if (stepIndex >= this._steps.length) {
            this._currentStep = this._steps.length - 1;
          }
          else {
            this._currentStep = stepIndex;
          }
        }
      }

      steps.push(this._steps[this._currentStep]);
      // Emits event
      this.onActiveStepChanged.emit(steps);
    }
    else {
      console.warn('Invalid step index provided')
    }
  }

  get steps() {
    return this._steps.slice();
  }

  set steps(stepList: Step[]) {
    this._steps = stepList;
  }

  get hasActiveStep(){
    return this._steps.length > 0 && this.currentStepIndex !== null;
  }

  get isAtLastStep(){
    return this.currentStepIndex === this.numberOfSteps - 1;
  }

  get isAtFirstStep(){
    return this.currentStepIndex === 0;
  }

  public setStepActive(stepIndex: number){
    if(JavascriptMethods.isInteger(stepIndex)){
      if(stepIndex > -1){
        if(stepIndex < this._steps.length){
          this.currentStepIndex = stepIndex;
          this.setActiveStep();
        }
        else{
          console.warn('Provided index is out of range.')
        }
      }
      else{
        console.warn('Provided index is out of range.')
      }
    }
  }

  public clearAllSteps(){
    this._steps = [];
    this._currentStep = null;
  }
}
