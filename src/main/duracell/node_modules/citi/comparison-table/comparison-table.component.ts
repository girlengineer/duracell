import {Component, OnInit, Input, Output, EventEmitter} from '@angular/core';
import {JavascriptMethods} from '../utility/utility.classes';
import {Observable} from 'rxjs';
import {Http, Response} from '@angular/http';

/**
 * @Component: ComparisonTableComponent
 * @Description: Component for rendering a comparison table of a list of items
 * with various features or characteristics
 */
@Component({
  selector: 'citi-comparison-table',
  template: require('./comparison-table.component.html'),
  styles: [require('./comparison-table.component.css')]
})
export class ComparisonTableComponent implements OnInit {

  private _data: any[];
  private _options: any;
  private _isDesktopWidth: boolean;
  private _isProcessing: boolean = false;
  private _loadingMessage: string = '';
  private _emptyMessage: string = '';
  private _optionUrl: string = '';


  /**
   * @Event: onListItemClick
   * @Description: Emitted when an row header is clicked
   * @Return: Object
   */
  @Output() onListItemClick: EventEmitter<any> = new EventEmitter() as EventEmitter<any>;

  /**
   * @Event: onAllItemClick
   * @Description: This event that is fired when the menu is clicked. The event is returned.
   * @Return: Array
   */
  @Output() onAllItemClick: EventEmitter<Array<any>> = new EventEmitter() as EventEmitter<Array<any>>;

  /**
   * @Property: emptyMessage
   * @Description: Sets the message when there is no data in the table
   * @Type: string
   */
  @Input() set emptyMessage(newMessage: string) {
    this._emptyMessage = newMessage;
  }
  /**
    * @Function: emptyMessage
    * @Description: Gets the message when there is no data in the table
    * @Return: Void
  */
  get emptyMessage() {
    if (this._emptyMessage !== undefined && this._emptyMessage !== '') {
      return this._emptyMessage;
    }
    return 'No data provided';
  }

  /**
   * @Property: isDesktopWidth
   * @Description: Sets the flag indicating the table is rendered in a viewport whose width is greater 768 pixels
   * @Type: boolean
   */
  @Input() set isDesktopWidth(value: boolean) {
    this._isDesktopWidth = value;
  }

  /**
   * @Property: isDesktopWidth
   * @Description: Gets the flag indicating the table is rendered in a viewport whose width is greater 768 pixels
   * @Type: boolean
   */
  get isDesktopWidth() {
    return this._isDesktopWidth;
  }

  /**
   * @Property: options
   * @Description: Sets options for the table
   * @Type: Object
   */
  @Input() set options(newOptions) {
    if (newOptions !== undefined) {
      this._options = JSON.parse(JSON.stringify(newOptions));
      if (this.options.hasOwnProperty('list')) {
        this.data = this.options.list.items;
      }
    }
  }

  /**
   * @Property: options
   * @Description: Gets the current options of the table
   * @Type: boolean
   */
  get options() {
    return JSON.parse(JSON.stringify(this._options));
  }

  /**
   * @Property: caption
   * @Description: Sets caption for the table
   * @Type: string
   */
  @Input() set caption(newCaption: string) {
    this._options.caption = newCaption;
  }

  /**
   * @Property: caption
   * @Description: Gets the current options of the table
   * @Type: String
   */
  get caption() {
    return this._options.caption;
  }

  /**
   * @Property: data
   * @Description: Sets new list of items
   * @Type: Object
   */
  @Input() set data(newData) {
    if (JavascriptMethods.isArray(newData)) {
      this._data = newData.slice(0);
    }
    else {
      console.warn('Provided data is not an array');
    }
  }

  /**
   * @Property: data
   * @Description: Gets the list of items
   * @Type: Array
   */
  get data() {
    return this._data.slice(0);
  }

  /**
   * @Property: hasData
   * @Description: Checks if the table has some data
   * @Type: Boolean
   */
  get hasData() {
    return JavascriptMethods.isArray(this._data) && this._data.length > 0;
  }

  /**
   * @Property: isProcessing
   * @Description: Checks if the table is loading data
   * @Type: Boolean
   */
  get isProcessing() {
    return this._isProcessing;
  }

  /**
   * @Property: AllItemExpanded
   * @Description: Checks if all items in the table is being expanded
   * @Type: Boolean
   */
  public get allItemExpanded() {
    for (let listItem of this._options.displayedKeys) {
      if (listItem.expanded === false) {
        return false;
      }
    }
    return true;
  }

  /**
   * @Property: loadingMessage
   * @Description: Sets the message being displayed when the table is loading data
   * @Type: Boolean
   */
  @Input() set loadingMessage(message: string) {
    if (message !== '') {
      this._loadingMessage = message;
    }
  }

  /**
   * @Property: loadingMessage
   * @Description: Gets the message being displayed when the table is loading data
   * @Type: Boolean
   */
  get loadingMessage() {
    if (this._loadingMessage !== undefined && this._loadingMessage !== '') {
      return this._loadingMessage;
    }
    return 'Loading data ...';
  }

  constructor() {

  }

  ngOnInit() {
    this.onResize(null);

    Observable.fromEvent(window, 'resize')
      .debounceTime(500)
      .subscribe(e => {
        this.onResize(e);
      });
  }

  private onResize(event) {
    this.isDesktopWidth = document.body.clientWidth > 768;
  }

  /**
   * @Function: onItemClick
   * @Description: Handles the item click event
   * @Param: (Object) - item - Clicked item.
   * @Return: void
   */
  private onItemClick(item) {
    let selectedItem = null;
    for (let listItem of this._options.displayedKeys) {
      if (listItem.key === item.key) {
        listItem.expanded = !listItem.expanded;
        selectedItem = JSON.parse(JSON.stringify(listItem));
        break;
      }
    }
    this.onListItemClick.emit(selectedItem);
  }

  /**
   * @Function: onAllItemButtonClick
   * @Description: Handles all item expanding/collapsing button clicked
   * @Return: void
   */
  private onAllItemButtonClick(event) {
    for (let listItem of this._options.displayedKeys) {
      listItem.expanded = !this.allItemExpanded;
    }
    this.onAllItemClick.emit(this.data);
  }

  /**
   * @Function: showProcessingIndicator
   * @Description: The function displays the processing indicator with 'loadingMessage'
   * @Return: void
   */
  public showProcessingIndicator() {
    this._isProcessing = true;
  }

  /**
   * @Function: hideProcessingIndicator
   * @Description: The function hides the processing indicator
   * @Return: void
   */
  public hideProcessingIndicator() {
    this._isProcessing = false;
  }

  /**
   * @Function: subscribeToObservable
   * @Description: Subscribes to a user-defined observable. All callback are called with the progress indicator as
   * the context
   * @Param: (Observable) - observer - Observable provided by developer, should return a string as parameter
   * @Param: (Function) - onNext - Callback for 'Next' event
   * @Param: (Function) - onError - Callback for 'Error' event
   * @Param: (Function) - onComplete - Callback for 'Complete' event
   * @Return: void
   */
  public subscribeToObservable(observer: Observable<Object>, onNext: Function, onError?: Function,
                               onComplete?: Function) {
    let functionArray = [];

    if (typeof onNext === 'function') {
      functionArray.push(onNext.bind(this));
    }
    else {
      functionArray.push(null);
    }

    if (typeof onError === 'function') {
      functionArray.push(onError.bind(this));
    }
    else {
      functionArray.push(null);
    }

    if (typeof onComplete === 'function') {
      functionArray.push(onComplete.bind(this));
    }
    else {
      functionArray.push(null);
    }

    return observer.subscribe.apply(observer, functionArray);
  }
}
