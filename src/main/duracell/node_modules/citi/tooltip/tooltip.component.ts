import { Component, OnInit, Input, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
  selector: 'citi-tooltip',
  template: require('./tooltip.component.html')
})


export class TooltipComponent implements OnInit {

  private popupOpacity: number =0;
  private popupPosition: 'top' | 'bottom' | 'auto' | 'left' | 'right' = 'auto';
  private popupClicked: boolean = false;
  private _hasHelpIcon: string = 'true';
  private tooltipTarget: any;
  private title: string = '';
  private body: string = '';
  private additionalClassName: string = '';
  private isFocusTriggered: boolean = false;
  private zIndex: string = "-1";

  @ViewChild('popover') popover: ElementRef;
  @ViewChild('tooltipHelpIcon') tooltipHelpIcon: ElementRef;
  @Input()
  set position (position: any) {
    this.popupPosition = position;
  }
  @Input()
  set additionalClass (className: string) {
    this.additionalClassName = className;
  }
  @Input()
  set tooltipTargetElement (tooltipTargetElement: any) {
    this.tooltipTarget  = tooltipTargetElement;
  }
  @Input()
  set tooltipTitle (tooltipTitle: string) {
    this.title  = tooltipTitle;
  }
  @Input()
  set tooltipBody (body: string) {
    this.body  = body;
  }
  @Input()
  set hasHelpIcon (hasHelpIcon: string) {
    this._hasHelpIcon  = hasHelpIcon;
  }
  public togglePopup() {

    /*
    if (this.popupClicked === true) {
      this.popupClicked = false;
      this.popupOpacity = 0;
      this.zIndex = '-1';
      this.isFocusTriggered = false;
    } else {
      this.popupClicked = true;
      this.popupOpacity = 1;
      this.zIndex = '1060';
    }
    */
  }

  private blurListener(){
    this.isFocusTriggered = false;
    setTimeout(() => {
        if (!this.isFocusTriggered) {
          this.popupOpacity = 0;
          this.popupClicked = false;
          this.zIndex = '-1';
        }
      }, 100);
  }

  private focusInListener(){
    this.popupOpacity = 1;
    this.zIndex = '1060';
  }

  private focusOutListener(){
    this.popupOpacity = 0;
    this.zIndex = '-1';
  }

  private getPopoverPosition(): any {
    let element  = this._hasHelpIcon === 'true' && this.tooltipHelpIcon ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget;
    if (element) {
      if (this.popupPosition === 'auto') {
          this.popupPosition = this.b('right auto', element);
        }
      return this.popupPosition + ' ' + this.additionalClassName;
    }
    return '';
  }
  private getPopoverXYPosition(): any {
    let element  = this._hasHelpIcon === 'true' && this.tooltipHelpIcon ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget;
    if (element) {
      let bodyRect = document.body.getBoundingClientRect(),
          elemRect = element.getBoundingClientRect(),
          verticalOffset: any,
          horizontalOffset: any;
      switch (this.popupPosition) {
        case 'top' :
          verticalOffset   = elemRect.top - bodyRect.top  - this.popover.nativeElement.offsetHeight;
          horizontalOffset = elemRect.left - bodyRect.left + element.offsetWidth/2 - this.popover.nativeElement.offsetWidth/2;
          break;
        case 'bottom' :
          verticalOffset   = elemRect.top - bodyRect.top + element.offsetHeight;
          horizontalOffset = elemRect.left - bodyRect.left + element.offsetWidth/2 - this.popover.nativeElement.offsetWidth/2;
          break;
        case 'right' :
          verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight/2) + element.offsetHeight/2;
          horizontalOffset   = elemRect.left - bodyRect.left + element.offsetWidth;
          break;
        case 'left' :
          verticalOffset = elemRect.top - bodyRect.top - (this.popover.nativeElement.offsetHeight/2) + element.offsetHeight/2;
          horizontalOffset   = elemRect.left - bodyRect.left - this.popover.nativeElement.offsetWidth;
          break;
      }
      return {'display' : 'block', 'top': verticalOffset + 'px', 'left': horizontalOffset + 'px'};
    } else {
      return '';
    }
  }
  private b(a: any , b: any) {
        let windowDimention = {
            width: window.innerWidth,
            height: window.innerHeight
        },
        elementRect = b.getBoundingClientRect(),
        positionArr = {
            right: function() {
                return windowDimention.width - (elementRect.width + elementRect.left);
            },
            left: function() {
                return elementRect.left;
            },
            bottom: function() {
                return windowDimention.height - (elementRect.height + elementRect.top);
            }
        }
        , e = a.replace(/ *auto */i, '')
        , position = {
          pos: e,
          size: 0
        }
        , maxWidth = 340;
      if (positionArr[e]() <= maxWidth) {
        for (let side in positionArr) {
              let i = positionArr[side]();
              if (i >= maxWidth) {
                  e = side;
                  break;
                }
              i > position.size && (position.size = i, position.pos = side);
          }
      }
      e = (positionArr[e]() <= maxWidth) ? 'bottom' : e;
      return e;
  }

  constructor() { }

  ngOnInit () {

  }

  ngAfterViewInit () {

          let element: any = this._hasHelpIcon === 'true' ? this.tooltipHelpIcon.nativeElement : this.tooltipTarget ;
          element.addEventListener('click', (e: any) => {

              /*
              if (this.popupClicked === true) {
                this.popupClicked = false;
                this.popupOpacity = 0;
                this.zIndex = '-1';
              } else {
                this.popupClicked = true;
                this.popupOpacity = 1;
                this.zIndex = '1060';
              }
              */
          });
          element.addEventListener('mouseover', (e: any) => {
            this.popupOpacity = 1;
            this.zIndex = '1060';
          });
          element.addEventListener('mouseleave', (e: any) => {
            if (this.popupClicked === false) {
              this.popupOpacity = 0;
              this.zIndex = '-1';
            }
          });
          element.addEventListener('blur', (e: any) => {
            this.isFocusTriggered = false;
            setTimeout(() => {
              if (!this.isFocusTriggered) {
                this.popupOpacity = 0;
                this.popupClicked = false;
                this.zIndex = '-1';
              }
            }, 100);
          });
          element.addEventListener('focus', (e: any) => {
            this.focusInListener();
          });
          element.addEventListener('focusout', (e: any) => {
            this.focusOutListener();
          })
  }

}
